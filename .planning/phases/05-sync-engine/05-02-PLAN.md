---
phase: 05-sync-engine
plan: 02
title: Sync history recording
subsystem: plugins
tags: [ruby, model, sync-history, analytics]

# Dependency graph
requires:
  - phase: 05-sync-engine
    plan: 01
    provides: [SyncExecutionService, sync result hash structure]
  - phase: 01-foundation
    provides: [SyncHistory model with base schema]
provides:
  - Enhanced SyncHistory model with analytics methods
  - Sync result recording service
  - Plugin sync statistics and reporting
  - Failure tracking and error analysis
affects: [07-plugin-management-ui]

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Model scopes for analytics queries"
    - "Service object for result recording"
    - "Statistics aggregation methods"
---

# Plan: Sync History Recording

**Goal:** Enhance sync history tracking with proper result recording, success/failure handling, and analytics capabilities for the Plugin Management UI

## Context

### From Phase 1 (Foundation)
- `SyncHistory` model exists with:
  - `plugin_name`, `status` (enum: pending/running/completed/failed)
  - `started_at`, `completed_at`, `error_message`
  - `records_processed`, `records_created`, `records_updated`
  - Scopes: `recent` (last 10, by created_at desc), `for_plugin(name)`
  - `duration` method that calculates elapsed time

### From Phase 2 (Plugin Interface)
- `BasePlugin` handles sync lifecycle via helpers:
  - `create_sync_history` - creates pending record with started_at
  - `complete_sync(history, stats)` - marks completed with stats
  - `fail_sync(history, error)` - marks failed with error_message

### From Plan 05-01 (Sync Execution Service)
- `SyncExecutionService` executes plugin syncs
- Returns result hash: `{ success: true/false, plugin_name:, sync_history_id:, data:, error:, error_type: }`

### This Plan Adds
1. Enhanced SyncHistory model with analytics scopes and methods
2. SyncHistoryRecorder service for standardized result recording
3. Statistics methods for reporting and UI display

## Tasks

### Task 1: Enhance SyncHistory model with analytics scopes

Add scopes and methods to SyncHistory for analytics and UI needs.

**File:** `app/models/sync_history.rb` (modify existing)

```ruby
class SyncHistory < ApplicationRecord
  # Enums
  enum :status, { pending: 0, running: 1, completed: 2, failed: 3 }

  # Validations
  validates :plugin_name, presence: true
  validates :status, presence: true

  # Scopes - Basic
  scope :recent, -> { order(created_at: :desc).limit(10) }
  scope :for_plugin, ->(name) { where(plugin_name: name) }

  # Scopes - By status
  scope :successful, -> { completed }
  scope :unsuccessful, -> { failed }
  scope :in_progress, -> { where(status: [:pending, :running]) }

  # Scopes - Time-based
  scope :today, -> { where(created_at: Time.current.beginning_of_day..Time.current.end_of_day) }
  scope :this_week, -> { where(created_at: 1.week.ago..Time.current) }
  scope :this_month, -> { where(created_at: 1.month.ago..Time.current) }

  # Returns the duration of the sync in seconds
  # Returns nil if started_at or completed_at is missing
  def duration
    return nil unless started_at && completed_at

    completed_at - started_at
  end

  # Returns human-readable duration string
  # @return [String, nil] formatted duration (e.g., "1.2s", "45.3s", "2m 15s")
  def duration_formatted
    return nil unless duration

    if duration < 60
      format("%.1fs", duration)
    else
      minutes = (duration / 60).floor
      seconds = (duration % 60).round
      "#{minutes}m #{seconds}s"
    end
  end

  # Returns whether this sync is still in progress
  def in_progress?
    pending? || running?
  end

  # Returns whether this sync completed successfully
  def successful?
    completed?
  end

  # Returns a summary hash for UI display
  # @return [Hash] summary with key metrics
  def summary
    {
      id: id,
      plugin_name: plugin_name,
      status: status,
      started_at: started_at,
      completed_at: completed_at,
      duration: duration,
      duration_formatted: duration_formatted,
      records_processed: records_processed || 0,
      records_created: records_created || 0,
      records_updated: records_updated || 0,
      error_message: error_message,
      successful: successful?
    }
  end

  # Class methods for statistics
  class << self
    # Returns statistics for a specific plugin
    # @param plugin_name [String] the plugin name
    # @return [Hash] statistics hash
    def stats_for_plugin(plugin_name)
      scope = for_plugin(plugin_name)

      {
        plugin_name: plugin_name,
        total_syncs: scope.count,
        successful_syncs: scope.successful.count,
        failed_syncs: scope.unsuccessful.count,
        success_rate: calculate_success_rate(scope),
        last_sync: scope.order(created_at: :desc).first&.summary,
        last_successful_sync: scope.successful.order(created_at: :desc).first&.summary,
        last_failed_sync: scope.unsuccessful.order(created_at: :desc).first&.summary,
        average_duration: scope.successful.average(:completed_at, :started_at),
        total_records_processed: scope.successful.sum(:records_processed),
        syncs_today: scope.today.count,
        syncs_this_week: scope.this_week.count
      }
    end

    # Returns aggregate statistics across all plugins
    # @return [Hash] aggregate statistics
    def aggregate_stats
      {
        total_syncs: count,
        successful_syncs: successful.count,
        failed_syncs: unsuccessful.count,
        success_rate: calculate_success_rate(all),
        syncs_today: today.count,
        syncs_this_week: this_week.count,
        plugins_synced: distinct.pluck(:plugin_name).count,
        in_progress: in_progress.count
      }
    end

    private

    def calculate_success_rate(scope)
      total = scope.where(status: [:completed, :failed]).count
      return 0.0 if total.zero?

      ((scope.successful.count.to_f / total) * 100).round(1)
    end
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/models/sync_history.rb`
- File contains new scopes and methods

### Task 2: Create SyncHistoryRecorder service

Create a service that provides a clean interface for recording sync results, handling edge cases like orphaned syncs.

**File:** `app/services/sync_history_recorder.rb`

```ruby
# Service for recording and managing sync history entries
#
# Usage:
#   # Record a successful sync (typically called by SyncExecutionService)
#   recorder = SyncHistoryRecorder.new(plugin_name: "example")
#   history = recorder.record_start
#   # ... perform sync ...
#   recorder.record_success(history, records_processed: 10, records_created: 5, records_updated: 2)
#
#   # Record a failed sync
#   recorder.record_failure(history, error: "Connection timeout")
#
#   # Clean up orphaned pending/running syncs
#   SyncHistoryRecorder.cleanup_orphaned
#
class SyncHistoryRecorder
  attr_reader :plugin_name

  # Maximum duration before a sync is considered orphaned (stuck)
  ORPHAN_THRESHOLD = 1.hour

  def initialize(plugin_name:)
    @plugin_name = plugin_name
  end

  # Creates a new sync history entry with running status
  # @return [SyncHistory] the created record
  def record_start
    SyncHistory.create!(
      plugin_name: plugin_name,
      status: :running,
      started_at: Time.current
    )
  end

  # Marks a sync as completed with the given statistics
  # @param history [SyncHistory] the sync history record to update
  # @param stats [Hash] statistics (records_processed, records_created, records_updated)
  # @return [SyncHistory] the updated record
  def record_success(history, stats = {})
    history.update!(
      status: :completed,
      completed_at: Time.current,
      records_processed: stats[:records_processed] || 0,
      records_created: stats[:records_created] || 0,
      records_updated: stats[:records_updated] || 0
    )
    history
  end

  # Marks a sync as failed with the given error
  # @param history [SyncHistory] the sync history record to update
  # @param error [String] the error message
  # @return [SyncHistory] the updated record
  def record_failure(history, error:)
    history.update!(
      status: :failed,
      completed_at: Time.current,
      error_message: error
    )
    history
  end

  # Returns the most recent sync for this plugin
  # @return [SyncHistory, nil]
  def last_sync
    SyncHistory.for_plugin(plugin_name).order(created_at: :desc).first
  end

  # Returns the most recent successful sync for this plugin
  # @return [SyncHistory, nil]
  def last_successful_sync
    SyncHistory.for_plugin(plugin_name).successful.order(created_at: :desc).first
  end

  # Returns statistics for this plugin
  # @return [Hash]
  def stats
    SyncHistory.stats_for_plugin(plugin_name)
  end

  # Class method to clean up orphaned sync entries
  # Marks pending/running syncs older than ORPHAN_THRESHOLD as failed
  # @return [Integer] number of records cleaned up
  def self.cleanup_orphaned
    orphaned = SyncHistory.in_progress.where("started_at < ?", ORPHAN_THRESHOLD.ago)

    count = orphaned.count
    orphaned.update_all(
      status: :failed,
      completed_at: Time.current,
      error_message: "Sync timed out (orphaned process)"
    )
    count
  end

  # Class method to get all plugins with recent activity
  # @param limit [Integer] number of recent entries per plugin
  # @return [Hash] hash of plugin_name => recent sync histories
  def self.recent_by_plugin(limit: 5)
    result = {}

    SyncHistory.select(:plugin_name).distinct.pluck(:plugin_name).each do |name|
      result[name] = SyncHistory.for_plugin(name).recent.limit(limit).map(&:summary)
    end

    result
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/services/sync_history_recorder.rb`
- File contains all methods

### Task 3: Write comprehensive specs for enhanced SyncHistory

**File:** `spec/models/sync_history_spec.rb`

```ruby
require "rails_helper"

RSpec.describe SyncHistory, type: :model do
  describe "validations" do
    it { is_expected.to validate_presence_of(:plugin_name) }
  end

  describe "enums" do
    it "defines status enum with correct values" do
      expect(described_class.statuses).to eq(
        "pending" => 0, "running" => 1, "completed" => 2, "failed" => 3
      )
    end
  end

  describe "scopes" do
    let!(:completed_sync) do
      create(:sync_history, plugin_name: "test", status: :completed, created_at: 1.hour.ago)
    end
    let!(:failed_sync) do
      create(:sync_history, plugin_name: "test", status: :failed, created_at: 2.hours.ago)
    end
    let!(:running_sync) do
      create(:sync_history, plugin_name: "test", status: :running, created_at: 30.minutes.ago)
    end
    let!(:pending_sync) do
      create(:sync_history, plugin_name: "other", status: :pending, created_at: 10.minutes.ago)
    end

    describe ".recent" do
      it "returns records ordered by created_at desc, limited to 10" do
        recent = described_class.recent
        expect(recent.first).to eq(pending_sync)
        expect(recent.count).to be <= 10
      end
    end

    describe ".for_plugin" do
      it "returns records for specific plugin" do
        expect(described_class.for_plugin("test").count).to eq(3)
        expect(described_class.for_plugin("other").count).to eq(1)
      end
    end

    describe ".successful" do
      it "returns only completed syncs" do
        expect(described_class.successful).to contain_exactly(completed_sync)
      end
    end

    describe ".unsuccessful" do
      it "returns only failed syncs" do
        expect(described_class.unsuccessful).to contain_exactly(failed_sync)
      end
    end

    describe ".in_progress" do
      it "returns pending and running syncs" do
        expect(described_class.in_progress).to contain_exactly(running_sync, pending_sync)
      end
    end

    describe ".today" do
      it "returns syncs from today" do
        expect(described_class.today.count).to eq(4) # All created within test
      end
    end

    describe ".this_week" do
      it "returns syncs from the last week" do
        expect(described_class.this_week.count).to eq(4)
      end
    end
  end

  describe "#duration" do
    it "returns nil when started_at is nil" do
      history = build(:sync_history, started_at: nil, completed_at: Time.current)
      expect(history.duration).to be_nil
    end

    it "returns nil when completed_at is nil" do
      history = build(:sync_history, started_at: Time.current, completed_at: nil)
      expect(history.duration).to be_nil
    end

    it "returns duration in seconds" do
      started = Time.current
      completed = started + 30.seconds
      history = build(:sync_history, started_at: started, completed_at: completed)
      expect(history.duration).to be_within(0.1).of(30)
    end
  end

  describe "#duration_formatted" do
    it "returns nil when duration is nil" do
      history = build(:sync_history, started_at: nil)
      expect(history.duration_formatted).to be_nil
    end

    it "formats seconds" do
      history = build(:sync_history, started_at: Time.current, completed_at: Time.current + 1.5.seconds)
      expect(history.duration_formatted).to eq("1.5s")
    end

    it "formats minutes and seconds" do
      history = build(:sync_history, started_at: Time.current, completed_at: Time.current + 135.seconds)
      expect(history.duration_formatted).to eq("2m 15s")
    end
  end

  describe "#in_progress?" do
    it "returns true for pending status" do
      expect(build(:sync_history, status: :pending).in_progress?).to be true
    end

    it "returns true for running status" do
      expect(build(:sync_history, status: :running).in_progress?).to be true
    end

    it "returns false for completed status" do
      expect(build(:sync_history, status: :completed).in_progress?).to be false
    end

    it "returns false for failed status" do
      expect(build(:sync_history, status: :failed).in_progress?).to be false
    end
  end

  describe "#successful?" do
    it "returns true for completed status" do
      expect(build(:sync_history, status: :completed).successful?).to be true
    end

    it "returns false for other statuses" do
      expect(build(:sync_history, status: :failed).successful?).to be false
      expect(build(:sync_history, status: :pending).successful?).to be false
    end
  end

  describe "#summary" do
    let(:history) do
      create(:sync_history,
             plugin_name: "test",
             status: :completed,
             started_at: Time.current - 5.seconds,
             completed_at: Time.current,
             records_processed: 100,
             records_created: 50,
             records_updated: 25)
    end

    it "returns hash with all expected keys" do
      summary = history.summary

      expect(summary[:id]).to eq(history.id)
      expect(summary[:plugin_name]).to eq("test")
      expect(summary[:status]).to eq("completed")
      expect(summary[:started_at]).to be_present
      expect(summary[:completed_at]).to be_present
      expect(summary[:duration]).to be_within(0.1).of(5)
      expect(summary[:duration_formatted]).to eq("5.0s")
      expect(summary[:records_processed]).to eq(100)
      expect(summary[:records_created]).to eq(50)
      expect(summary[:records_updated]).to eq(25)
      expect(summary[:error_message]).to be_nil
      expect(summary[:successful]).to be true
    end
  end

  describe ".stats_for_plugin" do
    before do
      3.times { create(:sync_history, plugin_name: "test", status: :completed, records_processed: 10) }
      2.times { create(:sync_history, plugin_name: "test", status: :failed, error_message: "Error") }
      create(:sync_history, plugin_name: "other", status: :completed)
    end

    let(:stats) { described_class.stats_for_plugin("test") }

    it "returns correct counts" do
      expect(stats[:total_syncs]).to eq(5)
      expect(stats[:successful_syncs]).to eq(3)
      expect(stats[:failed_syncs]).to eq(2)
    end

    it "calculates success rate" do
      expect(stats[:success_rate]).to eq(60.0)
    end

    it "returns last sync summary" do
      expect(stats[:last_sync]).to be_a(Hash)
      expect(stats[:last_sync][:plugin_name]).to eq("test")
    end

    it "returns total records processed" do
      expect(stats[:total_records_processed]).to eq(30)
    end
  end

  describe ".aggregate_stats" do
    before do
      3.times { create(:sync_history, plugin_name: "plugin1", status: :completed) }
      2.times { create(:sync_history, plugin_name: "plugin2", status: :failed) }
      create(:sync_history, plugin_name: "plugin3", status: :running)
    end

    let(:stats) { described_class.aggregate_stats }

    it "returns aggregate counts" do
      expect(stats[:total_syncs]).to eq(6)
      expect(stats[:successful_syncs]).to eq(3)
      expect(stats[:failed_syncs]).to eq(2)
      expect(stats[:in_progress]).to eq(1)
    end

    it "counts distinct plugins" do
      expect(stats[:plugins_synced]).to eq(3)
    end

    it "calculates overall success rate" do
      # 3 successful out of 5 completed/failed (excluding running)
      expect(stats[:success_rate]).to eq(60.0)
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/models/sync_history_spec.rb`
- All examples pass

### Task 4: Write comprehensive specs for SyncHistoryRecorder

**File:** `spec/services/sync_history_recorder_spec.rb`

```ruby
require "rails_helper"

RSpec.describe SyncHistoryRecorder do
  let(:plugin_name) { "example" }
  let(:recorder) { described_class.new(plugin_name: plugin_name) }

  describe "#record_start" do
    it "creates a sync history with running status" do
      history = recorder.record_start

      expect(history).to be_persisted
      expect(history.plugin_name).to eq(plugin_name)
      expect(history.status).to eq("running")
      expect(history.started_at).to be_present
    end

    it "does not set completed_at" do
      history = recorder.record_start
      expect(history.completed_at).to be_nil
    end
  end

  describe "#record_success" do
    let!(:history) { recorder.record_start }

    it "updates status to completed" do
      recorder.record_success(history)

      history.reload
      expect(history.status).to eq("completed")
    end

    it "sets completed_at" do
      recorder.record_success(history)

      history.reload
      expect(history.completed_at).to be_present
    end

    it "records statistics" do
      recorder.record_success(history,
                              records_processed: 100,
                              records_created: 50,
                              records_updated: 30)

      history.reload
      expect(history.records_processed).to eq(100)
      expect(history.records_created).to eq(50)
      expect(history.records_updated).to eq(30)
    end

    it "defaults statistics to 0" do
      recorder.record_success(history)

      history.reload
      expect(history.records_processed).to eq(0)
      expect(history.records_created).to eq(0)
      expect(history.records_updated).to eq(0)
    end

    it "returns the updated history" do
      result = recorder.record_success(history)
      expect(result).to eq(history)
      expect(result.status).to eq("completed")
    end
  end

  describe "#record_failure" do
    let!(:history) { recorder.record_start }

    it "updates status to failed" do
      recorder.record_failure(history, error: "Connection timeout")

      history.reload
      expect(history.status).to eq("failed")
    end

    it "sets completed_at" do
      recorder.record_failure(history, error: "Error")

      history.reload
      expect(history.completed_at).to be_present
    end

    it "records error message" do
      recorder.record_failure(history, error: "API returned 500 error")

      history.reload
      expect(history.error_message).to eq("API returned 500 error")
    end

    it "returns the updated history" do
      result = recorder.record_failure(history, error: "Error")
      expect(result).to eq(history)
      expect(result.status).to eq("failed")
    end
  end

  describe "#last_sync" do
    before do
      create(:sync_history, plugin_name: plugin_name, created_at: 2.hours.ago)
      create(:sync_history, plugin_name: plugin_name, created_at: 1.hour.ago)
      create(:sync_history, plugin_name: "other", created_at: 30.minutes.ago)
    end

    it "returns most recent sync for the plugin" do
      last = recorder.last_sync
      expect(last.plugin_name).to eq(plugin_name)
      expect(last.created_at).to be > 1.5.hours.ago
    end

    it "returns nil when no syncs exist" do
      recorder = described_class.new(plugin_name: "nonexistent")
      expect(recorder.last_sync).to be_nil
    end
  end

  describe "#last_successful_sync" do
    before do
      create(:sync_history, plugin_name: plugin_name, status: :failed, created_at: 1.hour.ago)
      create(:sync_history, plugin_name: plugin_name, status: :completed, created_at: 2.hours.ago)
    end

    it "returns most recent successful sync" do
      last = recorder.last_successful_sync
      expect(last.status).to eq("completed")
    end
  end

  describe "#stats" do
    before do
      3.times { create(:sync_history, plugin_name: plugin_name, status: :completed) }
      create(:sync_history, plugin_name: plugin_name, status: :failed)
    end

    it "returns statistics for the plugin" do
      stats = recorder.stats

      expect(stats[:plugin_name]).to eq(plugin_name)
      expect(stats[:total_syncs]).to eq(4)
      expect(stats[:successful_syncs]).to eq(3)
      expect(stats[:failed_syncs]).to eq(1)
    end
  end

  describe ".cleanup_orphaned" do
    let!(:recent_running) { create(:sync_history, status: :running, started_at: 30.minutes.ago) }
    let!(:old_running) { create(:sync_history, status: :running, started_at: 2.hours.ago) }
    let!(:old_pending) { create(:sync_history, status: :pending, started_at: 3.hours.ago) }
    let!(:old_completed) { create(:sync_history, status: :completed, started_at: 2.hours.ago) }

    it "marks old in-progress syncs as failed" do
      count = described_class.cleanup_orphaned

      expect(count).to eq(2)

      old_running.reload
      expect(old_running.status).to eq("failed")
      expect(old_running.error_message).to include("timed out")
      expect(old_running.completed_at).to be_present

      old_pending.reload
      expect(old_pending.status).to eq("failed")
    end

    it "does not affect recent in-progress syncs" do
      described_class.cleanup_orphaned

      recent_running.reload
      expect(recent_running.status).to eq("running")
    end

    it "does not affect completed syncs" do
      described_class.cleanup_orphaned

      old_completed.reload
      expect(old_completed.status).to eq("completed")
    end
  end

  describe ".recent_by_plugin" do
    before do
      3.times { create(:sync_history, plugin_name: "plugin1") }
      2.times { create(:sync_history, plugin_name: "plugin2") }
    end

    it "returns hash of recent syncs by plugin" do
      result = described_class.recent_by_plugin(limit: 2)

      expect(result).to be_a(Hash)
      expect(result.keys).to contain_exactly("plugin1", "plugin2")
      expect(result["plugin1"].count).to eq(2)
      expect(result["plugin2"].count).to eq(2)
    end

    it "returns summaries not full records" do
      result = described_class.recent_by_plugin

      expect(result["plugin1"].first).to be_a(Hash)
      expect(result["plugin1"].first).to include(:id, :plugin_name, :status)
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/services/sync_history_recorder_spec.rb`
- All examples pass

## Acceptance Criteria

- [ ] SyncHistory model has analytics scopes (successful, unsuccessful, in_progress, today, this_week)
- [ ] SyncHistory model has `duration_formatted`, `summary`, `in_progress?`, `successful?` methods
- [ ] SyncHistory class methods `stats_for_plugin` and `aggregate_stats` work correctly
- [ ] SyncHistoryRecorder provides clean interface for recording sync results
- [ ] SyncHistoryRecorder.cleanup_orphaned marks stuck syncs as failed
- [ ] All specs pass with `bundle exec rspec spec/models/sync_history_spec.rb spec/services/sync_history_recorder_spec.rb`

## Rollback Plan

If issues are found:
1. Revert changes to `app/models/sync_history.rb`
2. Remove `app/services/sync_history_recorder.rb`
3. Remove new spec files

## Notes

- This plan enhances the SyncHistory model and provides recording utilities
- Plan 05-01 handles sync execution orchestration
- These analytics methods will be used by Phase 7 (Plugin Management UI)
- The cleanup_orphaned method can be called via a rake task or scheduled job in the future
