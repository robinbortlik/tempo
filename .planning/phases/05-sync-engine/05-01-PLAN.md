---
phase: 05-sync-engine
plan: 01
title: Sync execution service
subsystem: plugins
tags: [ruby, service, sync, execution]

# Dependency graph
requires:
  - phase: 04-plugin-configuration
    provides: [PluginConfigurationService, enabled_plugins method, credentials/settings retrieval]
  - phase: 03-plugin-registry
    provides: [PluginRegistry class, find/find! methods]
  - phase: 02-plugin-interface
    provides: [BasePlugin class, sync method contract, configuration helpers]
  - phase: 01-foundation
    provides: [SyncHistory model, PluginConfiguration model]
provides:
  - SyncExecutionService for running plugin syncs
  - Single plugin sync execution with validation
  - All enabled plugins batch sync capability
  - Sync result aggregation and reporting
affects: [06-audit-trail, 07-plugin-management-ui]

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Service object pattern for sync orchestration"
    - "Result hash pattern for operation outcomes"
    - "Validation before execution pattern"
---

# Plan: Sync Execution Service

**Goal:** Create a service that executes plugin sync methods with proper validation, error handling, and result reporting

## Context

### From Phase 1 (Foundation)
- `SyncHistory` model tracks sync operations with:
  - `plugin_name`, `status` (pending/running/completed/failed)
  - `started_at`, `completed_at`, `error_message`
  - `records_processed`, `records_created`, `records_updated`
  - Scopes: `recent`, `for_plugin(name)`

### From Phase 2 (Plugin Interface)
- `BasePlugin` defines the plugin contract:
  - Class methods: `name`, `version`, `description`
  - Instance method: `sync` returns `{ success: true/false, ... }`
  - Helper methods: `credentials`, `settings`, `configuration`
  - Sync lifecycle: `create_sync_history`, `complete_sync`, `fail_sync`

### From Phase 3 (Plugin Registry)
- `PluginRegistry.find!(name)` returns plugin class or raises `NotFoundError`
- `PluginRegistry.all` returns all plugin classes

### From Phase 4 (Plugin Configuration)
- `PluginConfigurationService.enabled_plugins` returns enabled configurations
- `PluginConfiguration.enabled` scope returns enabled plugin records
- Configuration stores credentials (encrypted) and settings (JSON)

### This Phase Adds
Service layer for:
1. Executing a single plugin's sync with validation
2. Executing all enabled plugins' syncs
3. Pre-flight checks (plugin exists, is enabled, has credentials)
4. Result aggregation for batch syncs

## Tasks

### Task 1: Create SyncExecutionService

Create service class that orchestrates plugin sync execution with proper validation.

**File:** `app/services/sync_execution_service.rb`

```ruby
# Service for executing plugin sync operations
#
# Usage:
#   # Execute single plugin sync
#   service = SyncExecutionService.new
#   result = service.execute(plugin_name: "example")
#   # => { success: true, plugin_name: "example", sync_history_id: 123, data: {...} }
#
#   # Execute all enabled plugins
#   results = service.execute_all
#   # => [{ success: true, plugin_name: "example", ... }, ...]
#
class SyncExecutionService
  # Custom error for sync validation failures
  class SyncError < StandardError; end
  class PluginNotEnabledError < SyncError; end
  class PluginNotConfiguredError < SyncError; end

  # Execute sync for a single plugin by name
  # @param plugin_name [String] the plugin's name
  # @return [Hash] result with :success, :plugin_name, :sync_history_id, and :data or :error
  def execute(plugin_name:)
    plugin_class = find_plugin!(plugin_name)
    validate_plugin_enabled!(plugin_name)
    validate_plugin_configured!(plugin_name)

    run_sync(plugin_class)
  rescue PluginRegistry::NotFoundError => e
    { success: false, plugin_name: plugin_name, error: e.message, error_type: :not_found }
  rescue PluginNotEnabledError => e
    { success: false, plugin_name: plugin_name, error: e.message, error_type: :not_enabled }
  rescue PluginNotConfiguredError => e
    { success: false, plugin_name: plugin_name, error: e.message, error_type: :not_configured }
  rescue StandardError => e
    { success: false, plugin_name: plugin_name, error: e.message, error_type: :execution_error }
  end

  # Execute sync for all enabled plugins
  # @return [Array<Hash>] array of results from each plugin sync
  def execute_all
    enabled_plugins.map do |config|
      execute(plugin_name: config.plugin_name)
    end
  end

  # Execute sync for all enabled and configured plugins (skip validation failures)
  # @return [Hash] aggregated results with :successful, :failed, :skipped counts
  def execute_all_with_summary
    results = execute_all

    {
      total: results.count,
      successful: results.count { |r| r[:success] },
      failed: results.count { |r| !r[:success] && r[:error_type] == :execution_error },
      skipped: results.count { |r| !r[:success] && [:not_enabled, :not_configured].include?(r[:error_type]) },
      results: results
    }
  end

  private

  # Find the plugin class or raise NotFoundError
  def find_plugin!(plugin_name)
    PluginRegistry.find!(plugin_name)
  end

  # Validate that the plugin is enabled
  def validate_plugin_enabled!(plugin_name)
    config = PluginConfiguration.find_by(plugin_name: plugin_name)
    unless config&.enabled?
      raise PluginNotEnabledError, "Plugin '#{plugin_name}' is not enabled"
    end
  end

  # Validate that the plugin has credentials configured
  def validate_plugin_configured!(plugin_name)
    config = PluginConfiguration.find_by(plugin_name: plugin_name)
    unless config&.has_credentials?
      raise PluginNotConfiguredError, "Plugin '#{plugin_name}' is not configured (missing credentials)"
    end
  end

  # Returns enabled plugin configurations
  def enabled_plugins
    PluginConfiguration.enabled
  end

  # Run the actual sync operation
  # @param plugin_class [Class] the plugin class to instantiate and sync
  # @return [Hash] result hash with sync details
  def run_sync(plugin_class)
    plugin = plugin_class.new

    # Update status to running
    # Note: The plugin's sync method handles creating/updating SyncHistory via BasePlugin helpers

    sync_result = plugin.sync

    # Get the most recent sync history for this plugin (created by plugin.sync)
    sync_history = SyncHistory.for_plugin(plugin_class.name).order(created_at: :desc).first

    {
      success: sync_result[:success],
      plugin_name: plugin_class.name,
      sync_history_id: sync_history&.id,
      data: sync_result
    }
  end
end
```

**Verification:**
- File exists at `app/services/sync_execution_service.rb`
- No syntax errors: `ruby -c app/services/sync_execution_service.rb`

### Task 2: Write comprehensive specs for SyncExecutionService

**File:** `spec/services/sync_execution_service_spec.rb`

```ruby
require "rails_helper"

RSpec.describe SyncExecutionService do
  let(:service) { described_class.new }
  let(:plugin_name) { "example" }

  describe "#execute" do
    context "when plugin is not found" do
      it "returns error result with not_found type" do
        result = service.execute(plugin_name: "nonexistent")

        expect(result[:success]).to be false
        expect(result[:plugin_name]).to eq("nonexistent")
        expect(result[:error_type]).to eq(:not_found)
        expect(result[:error]).to include("not found")
      end
    end

    context "when plugin is not enabled" do
      before do
        create(:plugin_configuration, plugin_name: plugin_name, enabled: false)
      end

      it "returns error result with not_enabled type" do
        result = service.execute(plugin_name: plugin_name)

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:not_enabled)
        expect(result[:error]).to include("not enabled")
      end
    end

    context "when plugin has no configuration" do
      it "returns error result with not_enabled type" do
        result = service.execute(plugin_name: plugin_name)

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:not_enabled)
      end
    end

    context "when plugin is enabled but not configured" do
      before do
        create(:plugin_configuration, plugin_name: plugin_name, enabled: true, credentials: nil)
      end

      it "returns error result with not_configured type" do
        result = service.execute(plugin_name: plugin_name)

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:not_configured)
        expect(result[:error]).to include("not configured")
      end
    end

    context "when plugin is enabled and configured" do
      before do
        create(:plugin_configuration,
               plugin_name: plugin_name,
               enabled: true,
               credentials: { api_key: "test_key" }.to_json)
      end

      it "executes the sync and returns success" do
        result = service.execute(plugin_name: plugin_name)

        expect(result[:success]).to be true
        expect(result[:plugin_name]).to eq(plugin_name)
        expect(result[:sync_history_id]).to be_present
        expect(result[:data]).to include(success: true)
      end

      it "creates a sync history record" do
        expect {
          service.execute(plugin_name: plugin_name)
        }.to change(SyncHistory, :count).by(1)
      end

      it "marks sync history as completed" do
        result = service.execute(plugin_name: plugin_name)

        history = SyncHistory.find(result[:sync_history_id])
        expect(history.status).to eq("completed")
        expect(history.completed_at).to be_present
      end
    end

    context "when sync raises an exception" do
      before do
        create(:plugin_configuration,
               plugin_name: plugin_name,
               enabled: true,
               credentials: { api_key: "test_key" }.to_json)

        # Mock the plugin to raise an error during sync
        allow_any_instance_of(ExamplePlugin).to receive(:sync).and_raise(StandardError, "API connection failed")
      end

      it "returns error result with execution_error type" do
        result = service.execute(plugin_name: plugin_name)

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:execution_error)
        expect(result[:error]).to eq("API connection failed")
      end
    end
  end

  describe "#execute_all" do
    context "with no enabled plugins" do
      it "returns empty array" do
        results = service.execute_all
        expect(results).to eq([])
      end
    end

    context "with multiple plugins" do
      before do
        create(:plugin_configuration,
               plugin_name: plugin_name,
               enabled: true,
               credentials: { api_key: "test" }.to_json)
        create(:plugin_configuration,
               plugin_name: "disabled_plugin",
               enabled: false)
      end

      it "executes sync for enabled plugins only" do
        results = service.execute_all

        expect(results.count).to eq(1)
        expect(results.first[:plugin_name]).to eq(plugin_name)
      end
    end

    context "with multiple enabled plugins" do
      before do
        # Only ExamplePlugin is registered, so we test with one enabled
        create(:plugin_configuration,
               plugin_name: plugin_name,
               enabled: true,
               credentials: { api_key: "test" }.to_json)
      end

      it "returns results for each plugin" do
        results = service.execute_all

        expect(results).to be_an(Array)
        expect(results.count).to eq(1)
        expect(results.first[:success]).to be true
      end
    end
  end

  describe "#execute_all_with_summary" do
    before do
      create(:plugin_configuration,
             plugin_name: plugin_name,
             enabled: true,
             credentials: { api_key: "test" }.to_json)
    end

    it "returns aggregated summary" do
      summary = service.execute_all_with_summary

      expect(summary[:total]).to eq(1)
      expect(summary[:successful]).to eq(1)
      expect(summary[:failed]).to eq(0)
      expect(summary[:skipped]).to eq(0)
      expect(summary[:results]).to be_an(Array)
    end

    context "with mixed results" do
      before do
        # Add a second enabled plugin that will fail validation (not configured)
        create(:plugin_configuration,
               plugin_name: "unconfigured_plugin",
               enabled: true,
               credentials: nil)
      end

      it "counts successful and skipped correctly" do
        summary = service.execute_all_with_summary

        # unconfigured_plugin isn't in registry, so it will be not_found
        # Only example plugin will be in results from enabled query
        expect(summary[:total]).to eq(2)
        expect(summary[:successful]).to eq(1)
      end
    end
  end

  describe "error classes" do
    it "defines SyncError base class" do
      expect(SyncExecutionService::SyncError).to be < StandardError
    end

    it "defines PluginNotEnabledError" do
      expect(SyncExecutionService::PluginNotEnabledError).to be < SyncExecutionService::SyncError
    end

    it "defines PluginNotConfiguredError" do
      expect(SyncExecutionService::PluginNotConfiguredError).to be < SyncExecutionService::SyncError
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/services/sync_execution_service_spec.rb`
- All examples pass

### Task 3: Add integration test for full sync workflow

Create an integration test that verifies the complete sync workflow from service call to database records.

**File:** `spec/services/sync_execution_service_integration_spec.rb`

```ruby
require "rails_helper"

RSpec.describe SyncExecutionService, "integration" do
  let(:service) { described_class.new }
  let(:plugin_name) { "example" }

  describe "full sync workflow" do
    let!(:configuration) do
      create(:plugin_configuration,
             plugin_name: plugin_name,
             enabled: true,
             credentials: { api_key: "integration_test_key" }.to_json,
             settings: { batch_size: 100 }.to_json)
    end

    it "executes complete sync workflow" do
      # Pre-conditions
      expect(SyncHistory.count).to eq(0)

      # Execute sync
      result = service.execute(plugin_name: plugin_name)

      # Verify result
      expect(result[:success]).to be true
      expect(result[:plugin_name]).to eq(plugin_name)

      # Verify sync history was created
      expect(SyncHistory.count).to eq(1)

      history = SyncHistory.last
      expect(history.plugin_name).to eq(plugin_name)
      expect(history.status).to eq("completed")
      expect(history.started_at).to be_present
      expect(history.completed_at).to be_present
      expect(history.error_message).to be_nil

      # Verify duration is reasonable (sync should be fast for example plugin)
      expect(history.duration).to be >= 0
      expect(history.duration).to be < 5 # Should complete in under 5 seconds
    end

    it "handles plugin accessing its configuration during sync" do
      # ExamplePlugin should be able to access credentials via BasePlugin helpers
      plugin = ExamplePlugin.new

      # Verify configuration is accessible
      expect(plugin.configuration).to eq(configuration)
      expect(plugin.credentials["api_key"]).to eq("integration_test_key")
      expect(plugin.settings["batch_size"]).to eq(100)

      # Execute sync through service
      result = service.execute(plugin_name: plugin_name)
      expect(result[:success]).to be true
    end

    it "records multiple sync runs in history" do
      3.times do
        service.execute(plugin_name: plugin_name)
      end

      expect(SyncHistory.for_plugin(plugin_name).count).to eq(3)

      # Verify recent scope works
      recent = SyncHistory.for_plugin(plugin_name).recent
      expect(recent.count).to eq(3)
      expect(recent.first.created_at).to be >= recent.last.created_at
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/services/sync_execution_service_integration_spec.rb`
- All examples pass

## Acceptance Criteria

- [ ] `SyncExecutionService` can execute a single plugin sync by name
- [ ] Service validates plugin exists, is enabled, and has credentials before executing
- [ ] Service returns consistent result hash with success/error status
- [ ] `execute_all` runs sync for all enabled plugins
- [ ] `execute_all_with_summary` provides aggregated results
- [ ] Error types are clearly distinguished (not_found, not_enabled, not_configured, execution_error)
- [ ] All specs pass with `bundle exec rspec spec/services/sync_execution_service_spec.rb spec/services/sync_execution_service_integration_spec.rb`

## Rollback Plan

If issues are found:
1. Remove `app/services/sync_execution_service.rb`
2. Remove spec files

## Notes

- This plan focuses on sync execution orchestration
- Plan 05-02 handles enhanced sync history recording and analysis
- The plugin itself handles creating/updating SyncHistory via BasePlugin helpers
- Service adds validation layer and batch execution capabilities
