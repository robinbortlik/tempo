---
phase: 04-plugin-configuration
plan: 01
title: Plugin configuration storage and retrieval
subsystem: plugins
tags: [ruby, service, configuration, credentials]

# Dependency graph
requires:
  - phase: 03-plugin-registry
    provides: [PluginRegistry class, plugin discovery, find/find! methods]
  - phase: 01-foundation
    provides: [PluginConfiguration model with encrypted credentials]
provides:
  - PluginConfigurationService for CRUD operations on plugin configs
  - Enable/disable plugin functionality
  - Secure credential storage and retrieval
  - Settings management per plugin
  - Integration with BasePlugin.configuration helper
affects: [05-sync-engine, 07-plugin-management-ui]

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Service object pattern for configuration management"
    - "Result hash pattern for operation outcomes"
---

# Plan: Plugin Configuration Storage and Retrieval

**Goal:** Create service layer for managing plugin configurations including enable/disable, credentials, and settings per plugin

## Context

### From Phase 1 (Foundation)
- `PluginConfiguration` model exists with:
  - `plugin_name` (string, unique, required)
  - `enabled` (boolean, default: false)
  - `credentials` (text, encrypted via Rails 7+ attribute encryption)
  - `settings` (text, JSON)
- Model has `credentials_hash` and `settings_hash` helper methods

### From Phase 2 (Plugin Interface)
- `BasePlugin` has `configuration` method that looks up `PluginConfiguration.find_by(plugin_name: self.class.name)`
- `credentials` and `settings` instance methods return parsed hashes

### From Phase 3 (Plugin Registry)
- `PluginRegistry.find(name)` / `PluginRegistry.find!(name)` for plugin lookup
- `PluginRegistry.registered_names` returns all plugin names

### This Phase Adds
Service layer for:
1. Creating/updating plugin configurations
2. Enabling/disabling plugins
3. Storing credentials securely
4. Managing settings
5. Retrieving configuration status for UI

## Tasks

### Task 1: Create PluginConfigurationService

Create service class with CRUD operations for plugin configurations.

**File:** `app/services/plugin_configuration_service.rb`

```ruby
# Service for managing plugin configurations (enable/disable, credentials, settings)
#
# Usage:
#   service = PluginConfigurationService.new(plugin_name: "example")
#   service.enable!
#   service.update_credentials(api_key: "secret123")
#   service.update_settings(sync_interval: "daily")
#
class PluginConfigurationService
  attr_reader :plugin_name, :plugin_class

  # Initialize with plugin name, validates plugin exists in registry
  # @param plugin_name [String] the plugin's name
  # @raise [PluginRegistry::NotFoundError] if plugin not found
  def initialize(plugin_name:)
    @plugin_name = plugin_name
    @plugin_class = PluginRegistry.find!(plugin_name)
  end

  # Returns the configuration record, creating if needed
  # @return [PluginConfiguration] the configuration record
  def configuration
    @configuration ||= PluginConfiguration.find_or_initialize_by(plugin_name: plugin_name)
  end

  # Returns whether the plugin is currently enabled
  # @return [Boolean]
  def enabled?
    configuration.persisted? && configuration.enabled?
  end

  # Returns whether the plugin has credentials configured
  # @return [Boolean]
  def configured?
    configuration.persisted? && configuration.credentials.present?
  end

  # Enables the plugin
  # @return [Hash] result with :success and :configuration or :errors
  def enable!
    configuration.enabled = true
    save_configuration
  end

  # Disables the plugin
  # @return [Hash] result with :success and :configuration or :errors
  def disable!
    configuration.enabled = false
    save_configuration
  end

  # Updates the plugin's credentials (merges with existing)
  # @param credentials [Hash] credentials to store (will be encrypted)
  # @return [Hash] result with :success and :configuration or :errors
  def update_credentials(credentials)
    existing = configuration.credentials_hash
    merged = existing.merge(credentials.stringify_keys)
    configuration.credentials = merged.to_json
    save_configuration
  end

  # Replaces all credentials with new values
  # @param credentials [Hash] credentials to store (will be encrypted)
  # @return [Hash] result with :success and :configuration or :errors
  def replace_credentials(credentials)
    configuration.credentials = credentials.to_json
    save_configuration
  end

  # Clears all stored credentials
  # @return [Hash] result with :success and :configuration or :errors
  def clear_credentials!
    configuration.credentials = nil
    save_configuration
  end

  # Updates the plugin's settings (merges with existing)
  # @param settings [Hash] settings to store
  # @return [Hash] result with :success and :configuration or :errors
  def update_settings(settings)
    existing = configuration.settings_hash
    merged = existing.merge(settings.stringify_keys)
    configuration.settings = merged.to_json
    save_configuration
  end

  # Replaces all settings with new values
  # @param settings [Hash] settings to store
  # @return [Hash] result with :success and :configuration or :errors
  def replace_settings(settings)
    configuration.settings = settings.to_json
    save_configuration
  end

  # Clears all stored settings
  # @return [Hash] result with :success and :configuration or :errors
  def clear_settings!
    configuration.settings = nil
    save_configuration
  end

  # Returns summary for UI display
  # @return [Hash] configuration summary
  def summary
    {
      plugin_name: plugin_name,
      plugin_version: plugin_class.version,
      plugin_description: plugin_class.description,
      enabled: enabled?,
      configured: configured?,
      has_settings: configuration.settings.present?,
      created_at: configuration.created_at,
      updated_at: configuration.updated_at
    }
  end

  # Class method to get summary for all registered plugins
  # @return [Array<Hash>] array of plugin summaries
  def self.all_plugins_summary
    PluginRegistry.all.map do |plugin_class|
      new(plugin_name: plugin_class.name).summary
    end
  end

  # Class method to get only enabled plugins
  # @return [Array<PluginConfiguration>] enabled plugin configurations
  def self.enabled_plugins
    PluginConfiguration.where(enabled: true)
  end

  private

  def save_configuration
    if configuration.save
      { success: true, configuration: configuration }
    else
      { success: false, errors: configuration.errors.full_messages }
    end
  rescue ActiveRecord::RecordInvalid => e
    { success: false, errors: e.record.errors.full_messages }
  end
end
```

**Verification:**
- File exists at `app/services/plugin_configuration_service.rb`
- No syntax errors: `ruby -c app/services/plugin_configuration_service.rb`

### Task 2: Write comprehensive specs for PluginConfigurationService

**File:** `spec/services/plugin_configuration_service_spec.rb`

```ruby
require "rails_helper"

RSpec.describe PluginConfigurationService do
  # Use ExamplePlugin which exists from Phase 2
  let(:plugin_name) { "example" }
  let(:service) { described_class.new(plugin_name: plugin_name) }

  describe "#initialize" do
    it "accepts a valid plugin name" do
      expect { described_class.new(plugin_name: "example") }.not_to raise_error
    end

    it "raises NotFoundError for unknown plugin" do
      expect { described_class.new(plugin_name: "nonexistent") }
        .to raise_error(PluginRegistry::NotFoundError)
    end

    it "stores the plugin class" do
      expect(service.plugin_class).to eq(ExamplePlugin)
    end
  end

  describe "#configuration" do
    context "when no configuration exists" do
      it "returns a new unpersisted record" do
        config = service.configuration
        expect(config).to be_a(PluginConfiguration)
        expect(config).not_to be_persisted
        expect(config.plugin_name).to eq(plugin_name)
      end
    end

    context "when configuration exists" do
      let!(:existing) { create(:plugin_configuration, plugin_name: plugin_name) }

      it "returns the existing record" do
        config = service.configuration
        expect(config).to eq(existing)
        expect(config).to be_persisted
      end
    end
  end

  describe "#enabled?" do
    context "when not configured" do
      it "returns false" do
        expect(service.enabled?).to be false
      end
    end

    context "when configured but disabled" do
      before { create(:plugin_configuration, plugin_name: plugin_name, enabled: false) }

      it "returns false" do
        expect(service.enabled?).to be false
      end
    end

    context "when configured and enabled" do
      before { create(:plugin_configuration, plugin_name: plugin_name, enabled: true) }

      it "returns true" do
        expect(service.enabled?).to be true
      end
    end
  end

  describe "#configured?" do
    context "when no configuration exists" do
      it "returns false" do
        expect(service.configured?).to be false
      end
    end

    context "when configuration exists but no credentials" do
      before { create(:plugin_configuration, plugin_name: plugin_name, credentials: nil) }

      it "returns false" do
        expect(service.configured?).to be false
      end
    end

    context "when configuration exists with credentials" do
      before do
        create(:plugin_configuration, plugin_name: plugin_name, credentials: { api_key: "secret" }.to_json)
      end

      it "returns true" do
        expect(service.configured?).to be true
      end
    end
  end

  describe "#enable!" do
    context "when no configuration exists" do
      it "creates configuration and enables it" do
        result = service.enable!
        expect(result[:success]).to be true
        expect(result[:configuration]).to be_persisted
        expect(result[:configuration].enabled).to be true
      end
    end

    context "when configuration exists" do
      let!(:config) { create(:plugin_configuration, plugin_name: plugin_name, enabled: false) }

      it "enables the existing configuration" do
        result = service.enable!
        expect(result[:success]).to be true
        expect(config.reload.enabled).to be true
      end
    end
  end

  describe "#disable!" do
    context "when configuration exists and is enabled" do
      let!(:config) { create(:plugin_configuration, plugin_name: plugin_name, enabled: true) }

      it "disables the configuration" do
        result = service.disable!
        expect(result[:success]).to be true
        expect(config.reload.enabled).to be false
      end
    end

    context "when no configuration exists" do
      it "creates disabled configuration" do
        result = service.disable!
        expect(result[:success]).to be true
        expect(result[:configuration].enabled).to be false
      end
    end
  end

  describe "#update_credentials" do
    context "when no existing credentials" do
      it "stores new credentials" do
        result = service.update_credentials(api_key: "secret123", account_id: "acc_001")
        expect(result[:success]).to be true

        config = result[:configuration]
        expect(config.credentials_hash["api_key"]).to eq("secret123")
        expect(config.credentials_hash["account_id"]).to eq("acc_001")
      end
    end

    context "when credentials already exist" do
      before do
        create(:plugin_configuration, plugin_name: plugin_name, credentials: { api_key: "old_key" }.to_json)
      end

      it "merges with existing credentials" do
        result = service.update_credentials(secret_token: "new_token")
        expect(result[:success]).to be true

        config = result[:configuration]
        expect(config.credentials_hash["api_key"]).to eq("old_key")
        expect(config.credentials_hash["secret_token"]).to eq("new_token")
      end

      it "overwrites matching keys" do
        result = service.update_credentials(api_key: "new_key")
        expect(result[:success]).to be true

        config = result[:configuration]
        expect(config.credentials_hash["api_key"]).to eq("new_key")
      end
    end
  end

  describe "#replace_credentials" do
    before do
      create(:plugin_configuration, plugin_name: plugin_name, credentials: { old_key: "old_value" }.to_json)
    end

    it "replaces all credentials" do
      result = service.replace_credentials(new_key: "new_value")
      expect(result[:success]).to be true

      config = result[:configuration]
      expect(config.credentials_hash).to eq({ "new_key" => "new_value" })
      expect(config.credentials_hash["old_key"]).to be_nil
    end
  end

  describe "#clear_credentials!" do
    before do
      create(:plugin_configuration, plugin_name: plugin_name, credentials: { api_key: "secret" }.to_json)
    end

    it "clears all credentials" do
      result = service.clear_credentials!
      expect(result[:success]).to be true
      expect(result[:configuration].credentials).to be_nil
    end
  end

  describe "#update_settings" do
    context "when no existing settings" do
      it "stores new settings" do
        result = service.update_settings(sync_interval: "daily", max_records: 100)
        expect(result[:success]).to be true

        config = result[:configuration]
        expect(config.settings_hash["sync_interval"]).to eq("daily")
        expect(config.settings_hash["max_records"]).to eq(100)
      end
    end

    context "when settings already exist" do
      before do
        create(:plugin_configuration, plugin_name: plugin_name, settings: { sync_interval: "weekly" }.to_json)
      end

      it "merges with existing settings" do
        result = service.update_settings(max_records: 50)
        expect(result[:success]).to be true

        config = result[:configuration]
        expect(config.settings_hash["sync_interval"]).to eq("weekly")
        expect(config.settings_hash["max_records"]).to eq(50)
      end
    end
  end

  describe "#replace_settings" do
    before do
      create(:plugin_configuration, plugin_name: plugin_name, settings: { old_setting: "old_value" }.to_json)
    end

    it "replaces all settings" do
      result = service.replace_settings(new_setting: "new_value")
      expect(result[:success]).to be true

      config = result[:configuration]
      expect(config.settings_hash).to eq({ "new_setting" => "new_value" })
    end
  end

  describe "#clear_settings!" do
    before do
      create(:plugin_configuration, plugin_name: plugin_name, settings: { setting: "value" }.to_json)
    end

    it "clears all settings" do
      result = service.clear_settings!
      expect(result[:success]).to be true
      expect(result[:configuration].settings).to be_nil
    end
  end

  describe "#summary" do
    context "when not configured" do
      it "returns summary with default values" do
        summary = service.summary
        expect(summary[:plugin_name]).to eq("example")
        expect(summary[:plugin_version]).to eq(ExamplePlugin.version)
        expect(summary[:plugin_description]).to eq(ExamplePlugin.description)
        expect(summary[:enabled]).to be false
        expect(summary[:configured]).to be false
        expect(summary[:has_settings]).to be false
      end
    end

    context "when fully configured" do
      before do
        create(:plugin_configuration,
               plugin_name: plugin_name,
               enabled: true,
               credentials: { api_key: "secret" }.to_json,
               settings: { interval: "daily" }.to_json)
      end

      it "returns complete summary" do
        summary = service.summary
        expect(summary[:enabled]).to be true
        expect(summary[:configured]).to be true
        expect(summary[:has_settings]).to be true
        expect(summary[:created_at]).to be_present
        expect(summary[:updated_at]).to be_present
      end
    end
  end

  describe ".all_plugins_summary" do
    it "returns summary for all registered plugins" do
      summaries = described_class.all_plugins_summary
      expect(summaries).to be_an(Array)
      expect(summaries.length).to eq(PluginRegistry.all.length)
      expect(summaries.first).to include(:plugin_name, :enabled, :configured)
    end
  end

  describe ".enabled_plugins" do
    before do
      create(:plugin_configuration, plugin_name: plugin_name, enabled: true)
      create(:plugin_configuration, plugin_name: "disabled_plugin", enabled: false)
    end

    it "returns only enabled plugin configurations" do
      enabled = described_class.enabled_plugins
      expect(enabled.count).to eq(1)
      expect(enabled.first.plugin_name).to eq(plugin_name)
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/services/plugin_configuration_service_spec.rb`
- All examples pass

### Task 3: Enhance PluginConfiguration model with scopes and validation

Add useful scopes and ensure model aligns with service layer needs.

**File:** `app/models/plugin_configuration.rb` (modify existing)

```ruby
class PluginConfiguration < ApplicationRecord
  # Encryption
  encrypts :credentials

  # Validations
  validates :plugin_name, presence: true, uniqueness: true

  # Scopes
  scope :enabled, -> { where(enabled: true) }
  scope :disabled, -> { where(enabled: false) }
  scope :configured, -> { where.not(credentials: [nil, ""]) }

  # Returns the credentials as a parsed hash
  def credentials_hash
    return {} if credentials.blank?

    JSON.parse(credentials)
  rescue JSON::ParserError
    {}
  end

  # Returns the settings as a parsed hash
  def settings_hash
    return {} if settings.blank?

    JSON.parse(settings)
  rescue JSON::ParserError
    {}
  end

  # Returns whether the plugin has any credentials stored
  def has_credentials?
    credentials.present?
  end

  # Returns whether the plugin has any settings stored
  def has_settings?
    settings.present?
  end
end
```

**Verification:**
- Run existing model specs to ensure no regressions
- Run: `bundle exec rspec spec/models/plugin_configuration_spec.rb` (if exists)

### Task 4: Add model specs for PluginConfiguration enhancements

**File:** `spec/models/plugin_configuration_spec.rb`

```ruby
require "rails_helper"

RSpec.describe PluginConfiguration, type: :model do
  describe "validations" do
    subject { build(:plugin_configuration) }

    it { is_expected.to validate_presence_of(:plugin_name) }
    it { is_expected.to validate_uniqueness_of(:plugin_name) }
  end

  describe "scopes" do
    let!(:enabled_config) { create(:plugin_configuration, plugin_name: "enabled_plugin", enabled: true) }
    let!(:disabled_config) { create(:plugin_configuration, plugin_name: "disabled_plugin", enabled: false) }
    let!(:configured_config) do
      create(:plugin_configuration, plugin_name: "configured_plugin", credentials: { key: "value" }.to_json)
    end

    describe ".enabled" do
      it "returns only enabled configurations" do
        expect(described_class.enabled).to include(enabled_config)
        expect(described_class.enabled).not_to include(disabled_config)
      end
    end

    describe ".disabled" do
      it "returns only disabled configurations" do
        expect(described_class.disabled).to include(disabled_config)
        expect(described_class.disabled).not_to include(enabled_config)
      end
    end

    describe ".configured" do
      it "returns configurations with credentials" do
        expect(described_class.configured).to include(configured_config)
        expect(described_class.configured).not_to include(enabled_config)
      end
    end
  end

  describe "#credentials_hash" do
    it "returns empty hash when credentials is nil" do
      config = build(:plugin_configuration, credentials: nil)
      expect(config.credentials_hash).to eq({})
    end

    it "returns empty hash when credentials is empty" do
      config = build(:plugin_configuration, credentials: "")
      expect(config.credentials_hash).to eq({})
    end

    it "returns parsed JSON hash" do
      config = build(:plugin_configuration, credentials: { api_key: "secret" }.to_json)
      expect(config.credentials_hash).to eq({ "api_key" => "secret" })
    end

    it "returns empty hash for invalid JSON" do
      config = build(:plugin_configuration)
      config.instance_variable_set(:@_credentials_before_type_cast, "invalid json")
      # Force bypass encryption for test
      allow(config).to receive(:credentials).and_return("invalid json")
      expect(config.credentials_hash).to eq({})
    end
  end

  describe "#settings_hash" do
    it "returns empty hash when settings is nil" do
      config = build(:plugin_configuration, settings: nil)
      expect(config.settings_hash).to eq({})
    end

    it "returns empty hash when settings is empty" do
      config = build(:plugin_configuration, settings: "")
      expect(config.settings_hash).to eq({})
    end

    it "returns parsed JSON hash" do
      config = build(:plugin_configuration, settings: { interval: "daily" }.to_json)
      expect(config.settings_hash).to eq({ "interval" => "daily" })
    end
  end

  describe "#has_credentials?" do
    it "returns false when credentials is nil" do
      config = build(:plugin_configuration, credentials: nil)
      expect(config.has_credentials?).to be false
    end

    it "returns false when credentials is empty" do
      config = build(:plugin_configuration, credentials: "")
      expect(config.has_credentials?).to be false
    end

    it "returns true when credentials present" do
      config = build(:plugin_configuration, credentials: { key: "value" }.to_json)
      expect(config.has_credentials?).to be true
    end
  end

  describe "#has_settings?" do
    it "returns false when settings is nil" do
      config = build(:plugin_configuration, settings: nil)
      expect(config.has_settings?).to be false
    end

    it "returns true when settings present" do
      config = build(:plugin_configuration, settings: { key: "value" }.to_json)
      expect(config.has_settings?).to be true
    end
  end

  describe "encryption" do
    it "encrypts credentials at rest" do
      config = create(:plugin_configuration, plugin_name: "test_encryption", credentials: { api_key: "super_secret" }.to_json)

      # The raw database value should be encrypted (not plain JSON)
      raw_value = ActiveRecord::Base.connection.execute(
        "SELECT credentials FROM plugin_configurations WHERE id = #{config.id}"
      ).first["credentials"]

      expect(raw_value).not_to include("super_secret")
      expect(config.credentials_hash["api_key"]).to eq("super_secret")
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/models/plugin_configuration_spec.rb`
- All examples pass

## Acceptance Criteria

- [ ] `PluginConfigurationService` can enable/disable plugins
- [ ] Credentials are stored encrypted and retrievable
- [ ] Settings are stored and retrievable as JSON
- [ ] Service validates plugin exists via `PluginRegistry.find!`
- [ ] Model has scopes for enabled, disabled, and configured plugins
- [ ] All specs pass with `bundle exec rspec spec/services/plugin_configuration_service_spec.rb spec/models/plugin_configuration_spec.rb`

## Rollback Plan

If issues are found:
1. Remove `app/services/plugin_configuration_service.rb`
2. Revert changes to `app/models/plugin_configuration.rb`
3. Remove new spec files

## Notes

- This phase builds the service layer foundation needed for Phase 5 (Sync Engine) and Phase 7 (Plugin Management UI)
- The service pattern follows existing codebase conventions (see `InvoiceBuilder`, `ClientStatsService`)
- Result hash pattern used for consistency with other services
- Model enhancements are additive and backward-compatible
