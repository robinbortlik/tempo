---
phase: 08-example-plugin
plan: 02
title: Plugin developer documentation
subsystem: docs
tags: [documentation, plugins, developer-guide]

# Dependency graph
requires:
  - phase: 08-example-plugin
    plan: 01
    provides: [Complete ExamplePlugin implementation, MockBankApiClient]
  - phase: 02-plugin-interface
    provides: [BasePlugin contract]
  - phase: 06-audit-trail
    provides: [Auditable concern, audit context]
provides:
  - PLUGIN_DEVELOPMENT.md comprehensive guide
  - Plugin architecture documentation
  - Step-by-step tutorial with code examples
  - Testing patterns for plugins
  - Best practices and common pitfalls
affects: []

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Documentation-driven development examples"
    - "Code snippet extraction from working plugin"
---

# Plan: Plugin Developer Documentation

**Goal:** Create comprehensive documentation for developers creating new plugins, using ExamplePlugin as the reference implementation

## Context

### From Phase 2 (Plugin Interface)
- `BasePlugin` defines the contract:
  - Class methods: `name`, `version`, `description`
  - Instance method: `sync`
  - Optional class methods: `credential_fields`, `setting_fields`
  - Helpers: `configuration`, `credentials`, `settings`
  - Sync lifecycle: `create_sync_history`, `complete_sync`, `fail_sync`
  - Audit wrapper: `sync_with_audit`

### From Phase 6 (Audit Trail)
- `Auditable` concern auto-logs create/update/destroy
- `Current.with_audit_context` sets source attribution
- `DataAuditLog` stores all changes

### From Plan 08-01
- `ExamplePlugin` serves as the reference implementation
- `MockBankApiClient` demonstrates API client pattern
- Full sync workflow with deduplication

### This Plan Adds

1. `docs/PLUGIN_DEVELOPMENT.md` - Comprehensive developer guide
2. Architecture overview and design philosophy
3. Step-by-step plugin creation tutorial
4. Testing patterns and best practices
5. Troubleshooting guide

## Tasks

### Task 1: Create PLUGIN_DEVELOPMENT.md

**File:** `docs/PLUGIN_DEVELOPMENT.md`

```markdown
# Plugin Development Guide

This guide explains how to create plugins for the Invoicing application. Plugins enable integration with external services like banks, payment processors, and other APIs.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Quick Start](#quick-start)
3. [Plugin Contract](#plugin-contract)
4. [Configuration](#configuration)
5. [The Sync Method](#the-sync-method)
6. [Working with Data](#working-with-data)
7. [Error Handling](#error-handling)
8. [Testing Plugins](#testing-plugins)
9. [Best Practices](#best-practices)
10. [Troubleshooting](#troubleshooting)

---

## Architecture Overview

### Design Philosophy

Plugins are simple Ruby classes that follow a minimal contract:

- **One file, three methods**: A basic plugin needs only `name`, `version`, and `sync`
- **No magic**: Explicit registration, no metaprogramming or DSLs
- **Full access, full audit**: Plugins can access any model, but all changes are logged
- **Manual sync**: Users trigger syncs; no background job complexity

### How It Works

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  User clicks    │────>│ SyncExecution    │────>│ YourPlugin      │
│  "Sync" button  │     │ Service          │     │ .sync_with_audit│
└─────────────────┘     └──────────────────┘     └─────────────────┘
                                                         │
                        ┌──────────────────┐             │
                        │ SyncHistory      │<────────────┤
                        │ (tracks result)  │             │
                        └──────────────────┘             │
                                                         │
                        ┌──────────────────┐             │
                        │ DataAuditLog     │<────────────┤
                        │ (tracks changes) │             │
                        └──────────────────┘             │
                                                         │
                        ┌──────────────────┐             │
                        │ MoneyTransaction │<────────────┘
                        │ (your data)      │
                        └──────────────────┘
```

### Key Components

| Component | Purpose |
|-----------|---------|
| `BasePlugin` | Parent class providing helpers and contract |
| `PluginRegistry` | Discovers and lists available plugins |
| `PluginConfiguration` | Stores credentials and settings per plugin |
| `SyncExecutionService` | Validates and executes plugin syncs |
| `SyncHistory` | Records when syncs run and their outcomes |
| `DataAuditLog` | Tracks all data changes with source attribution |
| `MoneyTransaction` | Primary model for external financial data |

---

## Quick Start

### 1. Create the Plugin File

Create `app/plugins/my_bank_plugin.rb`:

```ruby
class MyBankPlugin < BasePlugin
  def self.name
    "my_bank"
  end

  def self.version
    "1.0.0"
  end

  def self.description
    "Integration with My Bank API"
  end

  def sync
    # Your sync logic here
    { success: true, records_processed: 0, records_created: 0, records_updated: 0 }
  end
end
```

### 2. Test It

```ruby
# In Rails console
plugin = MyBankPlugin.new
plugin.sync
# => { success: true, records_processed: 0, ... }
```

### 3. Configure via UI

1. Go to Settings > Plugins
2. Find "my_bank" in the list
3. Click Configure to add credentials
4. Enable the plugin
5. Click Sync to run

That's it! Your plugin is now integrated.

---

## Plugin Contract

### Required Class Methods

```ruby
class MyPlugin < BasePlugin
  # Unique identifier for this plugin (used in database, URLs)
  # Must be lowercase with underscores only
  def self.name
    "my_plugin"
  end

  # Semantic version string
  def self.version
    "1.0.0"
  end

  # Human-readable description shown in UI
  def self.description
    "Syncs transactions from My Service"
  end
end
```

### Required Instance Method

```ruby
class MyPlugin < BasePlugin
  # Main sync logic - called by SyncExecutionService
  # @return [Hash] must include :success key
  def sync
    # Fetch data from external API
    # Create/update records
    # Return result hash

    {
      success: true,
      records_processed: 10,
      records_created: 5,
      records_updated: 2
    }
  end
end
```

### Optional Class Methods

Define form fields for the configuration UI:

```ruby
class MyPlugin < BasePlugin
  # Credential fields (stored encrypted)
  def self.credential_fields
    [
      {
        name: "api_key",
        label: "API Key",
        type: "password",      # password, text, email
        required: true,
        description: "Your API key from the dashboard"
      },
      {
        name: "api_secret",
        label: "API Secret",
        type: "password",
        required: true
      }
    ]
  end

  # Setting fields (stored as JSON)
  def self.setting_fields
    [
      {
        name: "sync_from_date",
        label: "Sync from date",
        type: "date",
        required: false,
        description: "Only import transactions after this date"
      },
      {
        name: "import_limit",
        label: "Import limit",
        type: "number",
        required: false,
        description: "Maximum records per sync"
      }
    ]
  end
end
```

---

## Configuration

### Accessing Configuration

BasePlugin provides helpers to access stored configuration:

```ruby
class MyPlugin < BasePlugin
  def sync
    # Get the PluginConfiguration record
    config = configuration
    # => #<PluginConfiguration plugin_name: "my_plugin", enabled: true, ...>

    # Get credentials as a hash (decrypted automatically)
    creds = credentials
    # => { "api_key" => "secret123", "api_secret" => "xyz" }

    # Get settings as a hash
    opts = settings
    # => { "sync_from_date" => "2024-01-01", "import_limit" => "100" }

    # Use in your sync logic
    api_key = credentials["api_key"]
    limit = settings["import_limit"].to_i

    # ...
  end
end
```

### Credential Security

- Credentials are encrypted at rest using Rails 7+ attribute encryption
- Never log credential values
- Credentials are masked in the UI (showing only last 4 characters)
- The encryption key is stored in Rails credentials

---

## The Sync Method

### Return Value Contract

The `sync` method must return a hash with at least a `:success` key:

```ruby
# Success case
{
  success: true,
  records_processed: 10,  # Total records fetched from API
  records_created: 5,      # New records created
  records_updated: 2,      # Existing records updated
  # Optional: any additional data you want to return
  account_balance: 15420.50,
  last_transaction_date: "2024-01-15"
}

# Failure case
{
  success: false,
  error: "API returned 401 Unauthorized"
}
```

### Sync Lifecycle

When your plugin is called via `SyncExecutionService`, the workflow is:

1. **Validation**: Service checks plugin is enabled and has credentials
2. **Audit Context**: `sync_with_audit` sets `Current.audit_source` to your plugin name
3. **Sync History**: A `SyncHistory` record is created with `pending` status
4. **Your Code**: The `sync` method is called
5. **Data Changes**: Any model changes are logged to `DataAuditLog`
6. **Completion**: `SyncHistory` is updated with stats and `completed`/`failed` status

### Direct Sync vs sync_with_audit

```ruby
# Via SyncExecutionService (recommended)
# - Validates plugin is enabled
# - Validates credentials exist
# - Sets audit context
# - Records sync history automatically
SyncExecutionService.new.execute(plugin_name: "my_plugin")

# Direct call (for testing or manual use)
# - No validation
# - No audit context (changes won't have source)
# - You manage sync history
plugin = MyPlugin.new
plugin.sync

# With audit context (manual use with auditing)
plugin = MyPlugin.new
plugin.sync_with_audit
```

---

## Working with Data

### MoneyTransaction Model

The primary model for external financial data:

```ruby
MoneyTransaction.create!(
  # Required fields
  source: self.class.name,     # Your plugin name (for audit trail)
  amount: 1500.00,             # Always positive
  currency: "EUR",             # ISO currency code
  transacted_on: Date.current, # Transaction date

  # Transaction type
  transaction_type: :income,   # or :expense

  # Deduplication (strongly recommended)
  external_id: "TXN_123456",   # Unique ID from external system

  # Optional metadata
  description: "Invoice payment",
  counterparty: "Acme Corp",
  reference: "INV-2024-001",
  raw_data: api_response.to_json,  # Store original API response

  # Matching (optional)
  invoice_id: matched_invoice&.id
)
```

### Deduplication Pattern

Always use `external_id` to prevent duplicates:

```ruby
def sync
  transactions = fetch_from_api

  stats = { records_processed: 0, records_created: 0, records_updated: 0 }

  transactions.each do |txn|
    stats[:records_processed] += 1

    existing = MoneyTransaction.find_by(
      source: self.class.name,
      external_id: txn[:id]
    )

    if existing
      # Update if data changed
      if data_changed?(existing, txn)
        existing.update!(amount: txn[:amount], description: txn[:description])
        stats[:records_updated] += 1
      end
    else
      # Create new record
      MoneyTransaction.create!(
        source: self.class.name,
        external_id: txn[:id],
        # ... other fields
      )
      stats[:records_created] += 1
    end
  end

  { success: true, **stats }
end
```

### Audit Trail

All changes to `MoneyTransaction` (and other auditable models) are automatically logged:

```ruby
# After your plugin creates a transaction
txn = MoneyTransaction.last

# View audit history
txn.audit_history
# => [{ action: "create", source: "my_plugin", changes_made: {...}, ... }]

# Check who created it
txn.created_by
# => "my_plugin"

txn.created_by_plugin?
# => true
```

---

## Error Handling

### Handling API Errors

```ruby
def sync
  begin
    response = call_external_api

    if response.status == 401
      return { success: false, error: "Invalid API credentials" }
    end

    if response.status != 200
      return { success: false, error: "API error: #{response.status}" }
    end

    process_data(response.body)
    { success: true, records_processed: response.body.count }

  rescue Timeout::Error
    { success: false, error: "API request timed out" }
  rescue JSON::ParserError
    { success: false, error: "Invalid JSON response from API" }
  rescue StandardError => e
    { success: false, error: "Unexpected error: #{e.message}" }
  end
end
```

### Validation Errors

If `SyncExecutionService` can't run your plugin:

| Error Type | Cause | User Action |
|------------|-------|-------------|
| `not_found` | Plugin class not in `app/plugins/` | Check file exists and is named correctly |
| `not_enabled` | Plugin disabled in settings | Enable in Settings > Plugins |
| `not_configured` | No credentials stored | Configure in Settings > Plugins > Configure |
| `execution_error` | Exception in `sync` method | Check logs, fix plugin code |

---

## Testing Plugins

### Unit Testing the Plugin

```ruby
# spec/plugins/my_plugin_spec.rb
require "rails_helper"

RSpec.describe MyPlugin do
  describe "class methods" do
    it "returns plugin name" do
      expect(described_class.name).to eq("my_plugin")
    end

    it "returns version" do
      expect(described_class.version).to match(/\d+\.\d+\.\d+/)
    end

    it "returns description" do
      expect(described_class.description).to be_present
    end
  end

  describe "#sync" do
    let(:plugin) { described_class.new }

    before do
      # Set up configuration
      create(:plugin_configuration,
             plugin_name: "my_plugin",
             enabled: true,
             credentials: { api_key: "test_key" }.to_json)
    end

    context "with valid credentials" do
      before do
        # Stub external API calls
        stub_request(:get, "https://api.mybank.com/transactions")
          .to_return(status: 200, body: mock_transactions.to_json)
      end

      it "returns success" do
        result = plugin.sync
        expect(result[:success]).to be true
      end

      it "creates MoneyTransaction records" do
        expect { plugin.sync }.to change(MoneyTransaction, :count)
      end
    end

    context "with API error" do
      before do
        stub_request(:get, "https://api.mybank.com/transactions")
          .to_return(status: 500)
      end

      it "returns failure with error message" do
        result = plugin.sync
        expect(result[:success]).to be false
        expect(result[:error]).to be_present
      end
    end
  end
end
```

### Integration Testing

```ruby
# spec/integration/my_plugin_sync_spec.rb
require "rails_helper"

RSpec.describe "MyPlugin integration", type: :integration do
  let(:service) { SyncExecutionService.new }

  before do
    create(:plugin_configuration,
           plugin_name: "my_plugin",
           enabled: true,
           credentials: { api_key: "valid_key" }.to_json)

    # Stub external APIs
    stub_external_api
  end

  it "executes full sync workflow" do
    result = service.execute(plugin_name: "my_plugin")

    expect(result[:success]).to be true
    expect(MoneyTransaction.count).to be > 0
    expect(SyncHistory.last.status).to eq("completed")
    expect(DataAuditLog.for_source("my_plugin").count).to be > 0
  end
end
```

### Using Mock Clients

For development and testing, create a mock API client (see `ExamplePlugin::MockBankApiClient`):

```ruby
# app/plugins/my_plugin/mock_api_client.rb
class MyPlugin
  class MockApiClient
    def transactions(from:, to:)
      # Generate deterministic mock data based on dates
      # This enables testing without external dependencies
    end
  end
end

# In your plugin
def build_client
  if Rails.env.test? || credentials["use_mock"] == "true"
    MockApiClient.new
  else
    RealApiClient.new(api_key: credentials["api_key"])
  end
end
```

---

## Best Practices

### DO

- **Use external_id for deduplication** - Always store the external system's ID
- **Store raw_data** - Keep the original API response for debugging
- **Handle errors gracefully** - Return `{ success: false, error: "..." }` instead of raising
- **Respect rate limits** - Add delays if the API requires them
- **Log sparingly** - Use `Rails.logger.info` for important events only
- **Test with mocks** - Don't depend on external APIs in tests

### DON'T

- **Don't log credentials** - Never `puts` or `Rails.logger` API keys
- **Don't skip deduplication** - Always check for existing records
- **Don't ignore errors** - Surface them to the user via the result hash
- **Don't modify unrelated data** - Only touch records relevant to your plugin
- **Don't use background jobs** - Plugins run synchronously (v1 limitation)

### Naming Conventions

| Item | Convention | Example |
|------|------------|---------|
| Plugin class | `PascalCase` ending in `Plugin` | `FioBankPlugin` |
| Plugin name | `snake_case`, unique identifier | `fio_bank` |
| Plugin file | `snake_case.rb` in `app/plugins/` | `fio_bank_plugin.rb` |
| Helper classes | Nested under plugin class | `FioBankPlugin::ApiClient` |
| Helper files | In `app/plugins/{name}/` | `app/plugins/fio_bank_plugin/api_client.rb` |

---

## Troubleshooting

### Plugin Not Showing in List

1. Check file is in `app/plugins/` directory
2. Check class name matches file name (`my_plugin.rb` -> `MyPlugin`)
3. Check class inherits from `BasePlugin`
4. Restart Rails server (plugins loaded at boot)

### Sync Returns "Not Configured"

1. Go to Settings > Plugins > Configure
2. Enter all required credential fields
3. Save credentials
4. Try syncing again

### Transactions Not Being Created

1. Check `sync` method returns `{ success: true, ... }`
2. Check no exceptions are raised (wrap in begin/rescue)
3. Check `MoneyTransaction.create!` is being called
4. Check required fields are provided (source, amount, currency, transacted_on)

### Duplicates Being Created

1. Ensure `external_id` is set from the API's transaction ID
2. Check deduplication query uses both `source` and `external_id`
3. Verify `external_id` is unique in the source system

### Audit Logs Missing Source

1. Ensure sync is called via `SyncExecutionService.execute`
2. Or use `plugin.sync_with_audit` for manual calls
3. Check `Current.audit_source` is set during sync

### Debugging Tips

```ruby
# In Rails console
plugin = MyPlugin.new

# Check configuration is loaded
plugin.credentials
plugin.settings

# Run sync with detailed output
result = plugin.sync
pp result

# Check what was created
MoneyTransaction.where(source: "my_plugin").last

# Check sync history
SyncHistory.for_plugin("my_plugin").last

# Check audit logs
DataAuditLog.for_source("my_plugin").last
```

---

## Reference: ExamplePlugin

The `ExamplePlugin` in `app/plugins/example_plugin.rb` is a complete reference implementation demonstrating:

- Full `sync` method with API client
- Credential and setting field definitions
- Transaction deduplication
- Error handling patterns
- Mock API client for testing

Study it as a template for your own plugins.

---

## Getting Help

- Check existing plugins in `app/plugins/` for patterns
- Review `BasePlugin` source in `app/plugins/base_plugin.rb`
- Check specs in `spec/plugins/` for testing patterns
```

**Verification:**
- File renders correctly as markdown
- All code examples are syntactically correct
- Links in table of contents work

### Task 2: Add inline documentation to BasePlugin

Enhance the existing BasePlugin with more detailed documentation.

**File:** `app/plugins/base_plugin.rb` (update header comment)

Add comprehensive header documentation:

```ruby
# Base class for all plugins. Defines the contract that plugins must follow.
#
# == Plugin Contract
#
# Plugins are simple Ruby classes that extend BasePlugin. The minimal contract requires:
#
# === Required Class Methods
#
# - name        - Returns unique plugin identifier (string, lowercase with underscores)
# - version     - Returns semantic version string (e.g., "1.0.0")
# - description - Returns human-readable description for UI display
#
# === Required Instance Method
#
# - sync        - Performs the sync operation, returns result hash with :success key
#
# === Optional Class Methods
#
# - credential_fields - Array of field definitions for credential configuration UI
# - setting_fields    - Array of field definitions for settings configuration UI
#
# == Available Helpers
#
# Instance methods available in your plugin:
#
# - configuration      - Returns PluginConfiguration record for this plugin
# - credentials        - Returns decrypted credentials as Hash
# - settings           - Returns settings as Hash
# - create_sync_history - Creates SyncHistory with pending status
# - complete_sync(history, stats) - Marks sync as completed with stats
# - fail_sync(history, error) - Marks sync as failed with error message
# - sync_with_audit    - Wraps sync in audit context (used by SyncExecutionService)
#
# == Example
#
#   class MyBankPlugin < BasePlugin
#     def self.name
#       "my_bank"
#     end
#
#     def self.version
#       "1.0.0"
#     end
#
#     def self.description
#       "Sync transactions from My Bank"
#     end
#
#     def self.credential_fields
#       [{ name: "api_key", label: "API Key", type: "password", required: true }]
#     end
#
#     def sync
#       api_key = credentials["api_key"]
#       # ... fetch and process data ...
#       { success: true, records_processed: 10, records_created: 5 }
#     end
#   end
#
# == Sync Result Hash
#
# The sync method must return a Hash with at least :success key:
#
#   # Success
#   { success: true, records_processed: 10, records_created: 5, records_updated: 2 }
#
#   # Failure
#   { success: false, error: "API returned 401 Unauthorized" }
#
# == Audit Trail
#
# When sync is called via SyncExecutionService (or sync_with_audit directly),
# all data changes are automatically logged to DataAuditLog with your plugin
# name as the source. Use MoneyTransaction (which includes Auditable) for
# financial data to get automatic audit logging.
#
# See docs/PLUGIN_DEVELOPMENT.md for comprehensive documentation.
#
```

**Verification:**
- No syntax errors: `ruby -c app/plugins/base_plugin.rb`

### Task 3: Add YARD documentation to key methods

Ensure all public methods in BasePlugin have YARD documentation (already present, but verify and enhance).

The existing BasePlugin already has good YARD docs. No changes needed.

**Verification:**
- Review existing documentation is adequate

### Task 4: Create plugin architecture diagram as ASCII in docs

Already included in the PLUGIN_DEVELOPMENT.md Task 1 (the ASCII diagram showing sync flow).

### Task 5: Verify documentation accuracy

After 08-01 is complete, manually verify all code examples in the documentation work correctly.

**Manual Verification Checklist:**
- [ ] Quick Start example creates valid plugin
- [ ] Configuration access examples work
- [ ] MoneyTransaction example has correct fields
- [ ] Deduplication pattern compiles
- [ ] Error handling example compiles

## Acceptance Criteria

- [ ] `docs/PLUGIN_DEVELOPMENT.md` exists and is comprehensive
- [ ] Documentation covers: architecture, quick start, contract, configuration, sync method, data handling, errors, testing, best practices
- [ ] All code examples are syntactically correct Ruby
- [ ] Table of contents links work (markdown anchors)
- [ ] Architecture diagram clearly shows sync flow
- [ ] ExamplePlugin is referenced as the canonical example
- [ ] BasePlugin has comprehensive header documentation
- [ ] Troubleshooting section covers common issues

## Rollback Plan

If issues are found:
1. Remove `docs/PLUGIN_DEVELOPMENT.md`
2. Revert BasePlugin documentation changes

## Notes

- Documentation is based on the actual implementation, not hypothetical features
- Code examples are extracted from or inspired by ExamplePlugin
- The guide assumes readers have Ruby/Rails familiarity
- ASCII diagram chosen over images for git-friendliness and simplicity
- YARD documentation in BasePlugin provides IDE intellisense support
