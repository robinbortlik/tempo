---
phase: 08-example-plugin
plan: 01
title: Example bank plugin implementation
subsystem: plugins
tags: [ruby, plugin, mock, bank, transactions]

# Dependency graph
requires:
  - phase: 06-audit-trail
    provides: [Auditable concern, DataAuditLog, Current.with_audit_context]
  - phase: 05-sync-engine
    provides: [SyncExecutionService, sync workflow]
  - phase: 02-plugin-interface
    provides: [BasePlugin, sync_with_audit, credential_fields, setting_fields]
  - phase: 01-foundation
    provides: [MoneyTransaction model, SyncHistory model]
provides:
  - Fully functional ExampleBankPlugin with mock transactions
  - Realistic bank API simulation (account info, transactions)
  - Transaction deduplication via external_id
  - Configurable sync behavior (date range, limits)
  - Reference implementation for plugin developers
affects: [08-02]

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Mock API client pattern for testing/development"
    - "Transaction deduplication via external_id + source"
    - "Date-based filtering for incremental sync"
    - "Structured error handling in plugins"
---

# Plan: Example Bank Plugin Implementation

**Goal:** Transform ExamplePlugin into a realistic mock bank integration that demonstrates the full plugin lifecycle, creating MoneyTransaction records from simulated bank data

## Context

### From Phase 1 (Foundation)
- `MoneyTransaction` model with columns: source, amount, currency, transacted_on, transaction_type, external_id, description, counterparty, reference, raw_data, invoice_id
- Uniqueness constraint on `external_id` scoped to `source`
- Scopes: `income`, `expenses`, `unmatched`, `for_period`

### From Phase 2 (Plugin Interface)
- `BasePlugin` class with contract: `name`, `version`, `description` (class methods), `sync` (instance method)
- Helpers: `configuration`, `credentials`, `settings`, `create_sync_history`, `complete_sync`, `fail_sync`
- `sync_with_audit` wraps sync in audit context
- `credential_fields` and `setting_fields` class methods for UI forms

### From Phase 5 (Sync Engine)
- `SyncExecutionService` validates plugin is enabled and configured before running sync
- Plugins must be enabled and have credentials to sync

### From Phase 6 (Audit Trail)
- `Auditable` concern auto-logs changes to `DataAuditLog`
- `MoneyTransaction` includes `Auditable`
- `Current.with_audit_context` sets source attribution

### Current State
- `ExamplePlugin` exists as a stub that does nothing
- Has `credential_fields` and `setting_fields` defined
- Returns `{ success: true, records_processed: 0 }`

### This Plan Adds

1. `MockBankApiClient` - Simulates bank API responses
2. Upgraded `ExamplePlugin` that fetches mock transactions and creates `MoneyTransaction` records
3. Proper deduplication to avoid duplicate imports
4. Configurable date range and import limits
5. Comprehensive specs demonstrating plugin testing patterns

## Design Decisions

### Mock vs Real API
**Decision:** Use a mock API client embedded in the plugin

**Rationale:**
1. Enables testing without external dependencies
2. Demonstrates the pattern for real API integration
3. Provides predictable data for development and demos
4. Can be swapped for real API client in production plugins

### Transaction Data Shape
Mock transactions will mirror realistic bank API responses:
- Unique transaction ID (external_id)
- Amount (positive = income, negative = expense converted to positive)
- Date, counterparty name, reference/memo
- Raw JSON stored for debugging

## Tasks

### Task 1: Create MockBankApiClient class

Create an internal class within ExamplePlugin that simulates bank API responses.

**File:** `app/plugins/example_plugin/mock_bank_api_client.rb`

```ruby
# Mock bank API client for ExamplePlugin
# Simulates realistic bank API responses for development and testing
#
# Usage:
#   client = ExamplePlugin::MockBankApiClient.new(api_key: "test", account_id: "acc123")
#   client.account_info
#   # => { account_id: "acc123", account_name: "Business Account", currency: "EUR", balance: 15420.50 }
#
#   client.transactions(from_date: Date.current - 30, to_date: Date.current)
#   # => [{ id: "TXN001", ... }, ...]
#
class ExamplePlugin
  class MockBankApiClient
    MOCK_COUNTERPARTIES = [
      "Acme Corporation",
      "TechStart Inc.",
      "Global Services Ltd.",
      "Digital Solutions",
      "Creative Agency",
      "Consulting Partners",
      "Software Systems",
      "Innovation Labs"
    ].freeze

    MOCK_DESCRIPTIONS = [
      "Invoice payment",
      "Consulting services",
      "Project milestone",
      "Monthly retainer",
      "Development work",
      "Design services",
      "Support contract",
      "License renewal"
    ].freeze

    MOCK_EXPENSE_COUNTERPARTIES = [
      "Office Supplies Co",
      "Cloud Services Inc",
      "Domain Registrar",
      "Software License Ltd",
      "Coworking Space",
      "Internet Provider"
    ].freeze

    MOCK_EXPENSE_DESCRIPTIONS = [
      "Office supplies",
      "Cloud hosting",
      "Domain renewal",
      "Software subscription",
      "Workspace rental",
      "Internet service"
    ].freeze

    attr_reader :api_key, :account_id

    def initialize(api_key:, account_id: nil)
      @api_key = api_key
      @account_id = account_id || "MOCK_#{api_key[0..7]}"
    end

    # Validate credentials by checking API key format
    # @return [Boolean] true if credentials appear valid
    def valid_credentials?
      api_key.present? && api_key.length >= 8
    end

    # Get account information
    # @return [Hash] account details
    def account_info
      {
        account_id: account_id,
        account_name: "Business Account",
        currency: "EUR",
        balance: rand(5000.0..50000.0).round(2),
        iban: "CZ65 0800 0000 1920 0014 5399"
      }
    end

    # Fetch transactions within a date range
    # @param from_date [Date] start date
    # @param to_date [Date] end date (defaults to today)
    # @param limit [Integer] maximum transactions to return
    # @return [Array<Hash>] transaction records
    def transactions(from_date:, to_date: Date.current, limit: 100)
      # Generate deterministic but varied transactions based on date range
      all_transactions = generate_transactions(from_date, to_date)
      all_transactions.first(limit)
    end

    private

    # Generate mock transactions for a date range
    # Uses date-based seeding for deterministic results (same dates = same transactions)
    def generate_transactions(from_date, to_date)
      transactions = []
      current_date = from_date

      while current_date <= to_date
        # Seed random with date for deterministic results
        day_seed = current_date.to_s.hash.abs
        day_random = Random.new(day_seed)

        # Generate 0-3 transactions per day
        num_transactions = day_random.rand(0..3)

        num_transactions.times do |i|
          transactions << generate_transaction(current_date, i, day_random)
        end

        current_date += 1.day
      end

      transactions.sort_by { |t| t[:date] }.reverse
    end

    def generate_transaction(date, index, random)
      # 70% income, 30% expense
      is_income = random.rand < 0.7
      transaction_id = "TXN_#{date.strftime('%Y%m%d')}_#{format('%03d', index)}"

      if is_income
        {
          id: transaction_id,
          date: date,
          amount: (random.rand(500.0..5000.0) * 100).round / 100.0,
          currency: "EUR",
          counterparty: MOCK_COUNTERPARTIES[random.rand(MOCK_COUNTERPARTIES.length)],
          description: MOCK_DESCRIPTIONS[random.rand(MOCK_DESCRIPTIONS.length)],
          reference: "REF-#{date.strftime('%Y%m')}-#{random.rand(1000..9999)}",
          type: "credit"
        }
      else
        {
          id: transaction_id,
          date: date,
          amount: (random.rand(50.0..500.0) * 100).round / 100.0,
          currency: "EUR",
          counterparty: MOCK_EXPENSE_COUNTERPARTIES[random.rand(MOCK_EXPENSE_COUNTERPARTIES.length)],
          description: MOCK_EXPENSE_DESCRIPTIONS[random.rand(MOCK_EXPENSE_DESCRIPTIONS.length)],
          reference: "EXP-#{date.strftime('%Y%m')}-#{random.rand(1000..9999)}",
          type: "debit"
        }
      end
    end
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/plugins/example_plugin/mock_bank_api_client.rb`

### Task 2: Upgrade ExamplePlugin with full sync implementation

Replace the stub sync method with a real implementation that uses MockBankApiClient.

**File:** `app/plugins/example_plugin.rb` (full replacement)

```ruby
# Example bank plugin demonstrating the complete plugin interface.
# This serves as both a working reference implementation and documentation
# for developers creating new plugins.
#
# Features demonstrated:
# - Credential and setting field definitions
# - API client instantiation from credentials
# - Transaction fetching with date filtering
# - Deduplication via external_id
# - Audit trail integration
# - Error handling patterns
#
# Usage:
#   # Manual sync (for testing)
#   plugin = ExamplePlugin.new
#   result = plugin.sync
#
#   # Via SyncExecutionService (production)
#   SyncExecutionService.new.execute(plugin_name: "example")
#
class ExamplePlugin < BasePlugin
  # Load the mock API client
  require_relative "example_plugin/mock_bank_api_client"

  # Plugin identity - used for registration and configuration lookup
  def self.name
    "example"
  end

  def self.version
    "2.0.0"
  end

  def self.description
    "Example bank integration plugin - demonstrates the plugin interface with mock bank data"
  end

  # Credential fields shown in the configuration UI
  # Users enter their bank API credentials here
  # @return [Array<Hash>] field definitions
  def self.credential_fields
    [
      {
        name: "api_key",
        label: "API Key",
        type: "password",
        required: true,
        description: "Your bank API key (minimum 8 characters)"
      },
      {
        name: "account_id",
        label: "Account ID",
        type: "text",
        required: false,
        description: "Specific account to sync (optional, uses default if empty)"
      }
    ]
  end

  # Setting fields for sync behavior configuration
  # @return [Array<Hash>] field definitions
  def self.setting_fields
    [
      {
        name: "sync_from_date",
        label: "Sync from date",
        type: "date",
        required: false,
        description: "Only import transactions after this date (defaults to 30 days ago)"
      },
      {
        name: "import_limit",
        label: "Import limit",
        type: "number",
        required: false,
        description: "Maximum transactions to import per sync (default: 100)"
      },
      {
        name: "default_currency",
        label: "Default currency",
        type: "text",
        required: false,
        description: "Currency code for transactions (default: EUR)"
      }
    ]
  end

  # Main sync method - fetches transactions from the bank and creates MoneyTransaction records
  # Called by SyncExecutionService after validation (enabled + configured)
  #
  # @return [Hash] result with :success, :records_processed, :records_created, :records_updated, or :error
  def sync
    history = create_sync_history

    begin
      # Validate credentials before proceeding
      client = build_api_client
      unless client.valid_credentials?
        return fail_and_return(history, "Invalid API credentials - key must be at least 8 characters")
      end

      # Fetch transactions from the bank API
      from_date = sync_from_date
      to_date = Date.current
      limit = import_limit

      transactions = client.transactions(
        from_date: from_date,
        to_date: to_date,
        limit: limit
      )

      # Process each transaction
      stats = process_transactions(transactions)

      complete_sync(history, stats)

      {
        success: true,
        records_processed: stats[:records_processed],
        records_created: stats[:records_created],
        records_updated: stats[:records_updated],
        date_range: { from: from_date, to: to_date },
        account_info: client.account_info
      }
    rescue StandardError => e
      fail_and_return(history, e.message)
    end
  end

  private

  # Build the API client with configured credentials
  # @return [MockBankApiClient] configured client instance
  def build_api_client
    MockBankApiClient.new(
      api_key: credentials["api_key"] || "",
      account_id: credentials["account_id"]
    )
  end

  # Determine the sync start date from settings or default
  # @return [Date] start date for transaction fetch
  def sync_from_date
    if settings["sync_from_date"].present?
      Date.parse(settings["sync_from_date"])
    else
      30.days.ago.to_date
    end
  rescue ArgumentError
    30.days.ago.to_date
  end

  # Get import limit from settings or default
  # @return [Integer] maximum transactions to import
  def import_limit
    limit = settings["import_limit"].to_i
    limit.positive? ? limit : 100
  end

  # Get default currency from settings or default
  # @return [String] currency code
  def default_currency
    settings["default_currency"].presence || "EUR"
  end

  # Process transactions and create/update MoneyTransaction records
  # @param transactions [Array<Hash>] transactions from the API
  # @return [Hash] processing statistics
  def process_transactions(transactions)
    stats = { records_processed: 0, records_created: 0, records_updated: 0 }

    transactions.each do |txn|
      stats[:records_processed] += 1

      existing = find_existing_transaction(txn[:id])

      if existing
        if transaction_changed?(existing, txn)
          update_transaction(existing, txn)
          stats[:records_updated] += 1
        end
      else
        create_transaction(txn)
        stats[:records_created] += 1
      end
    end

    stats
  end

  # Find an existing transaction by external_id
  # @param external_id [String] the bank's transaction ID
  # @return [MoneyTransaction, nil]
  def find_existing_transaction(external_id)
    MoneyTransaction.find_by(source: self.class.name, external_id: external_id)
  end

  # Check if transaction data has changed (would need update)
  # @param existing [MoneyTransaction] existing record
  # @param txn [Hash] new transaction data
  # @return [Boolean]
  def transaction_changed?(existing, txn)
    existing.amount != txn[:amount] ||
      existing.description != txn[:description] ||
      existing.counterparty != txn[:counterparty]
  end

  # Create a new MoneyTransaction from bank transaction data
  # @param txn [Hash] transaction from API
  # @return [MoneyTransaction]
  def create_transaction(txn)
    MoneyTransaction.create!(
      source: self.class.name,
      external_id: txn[:id],
      amount: txn[:amount],
      currency: txn[:currency] || default_currency,
      transacted_on: txn[:date],
      transaction_type: txn[:type] == "credit" ? :income : :expense,
      description: txn[:description],
      counterparty: txn[:counterparty],
      reference: txn[:reference],
      raw_data: txn.to_json
    )
  end

  # Update an existing MoneyTransaction with new data
  # @param existing [MoneyTransaction] record to update
  # @param txn [Hash] new transaction data
  # @return [MoneyTransaction]
  def update_transaction(existing, txn)
    existing.update!(
      amount: txn[:amount],
      description: txn[:description],
      counterparty: txn[:counterparty],
      reference: txn[:reference],
      raw_data: txn.to_json
    )
    existing
  end

  # Mark sync as failed and return error result
  # @param history [SyncHistory] sync history record
  # @param error_message [String] error description
  # @return [Hash] error result
  def fail_and_return(history, error_message)
    fail_sync(history, error_message)
    { success: false, error: error_message }
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/plugins/example_plugin.rb`

### Task 3: Write specs for MockBankApiClient

**File:** `spec/plugins/example_plugin/mock_bank_api_client_spec.rb`

```ruby
require "rails_helper"

RSpec.describe ExamplePlugin::MockBankApiClient do
  let(:api_key) { "test_api_key_12345" }
  let(:account_id) { "ACC_001" }
  let(:client) { described_class.new(api_key: api_key, account_id: account_id) }

  describe "#initialize" do
    it "stores api_key and account_id" do
      expect(client.api_key).to eq(api_key)
      expect(client.account_id).to eq(account_id)
    end

    it "generates account_id from api_key if not provided" do
      client = described_class.new(api_key: api_key)
      expect(client.account_id).to start_with("MOCK_")
    end
  end

  describe "#valid_credentials?" do
    it "returns true for valid api_key (8+ chars)" do
      expect(client.valid_credentials?).to be true
    end

    it "returns false for short api_key" do
      client = described_class.new(api_key: "short")
      expect(client.valid_credentials?).to be false
    end

    it "returns false for blank api_key" do
      client = described_class.new(api_key: "")
      expect(client.valid_credentials?).to be false
    end
  end

  describe "#account_info" do
    let(:info) { client.account_info }

    it "returns account details hash" do
      expect(info).to be_a(Hash)
      expect(info[:account_id]).to eq(account_id)
      expect(info[:account_name]).to eq("Business Account")
      expect(info[:currency]).to eq("EUR")
    end

    it "includes balance" do
      expect(info[:balance]).to be_a(Float)
      expect(info[:balance]).to be > 0
    end

    it "includes IBAN" do
      expect(info[:iban]).to be_present
    end
  end

  describe "#transactions" do
    let(:from_date) { Date.current - 7 }
    let(:to_date) { Date.current }

    it "returns array of transaction hashes" do
      transactions = client.transactions(from_date: from_date, to_date: to_date)

      expect(transactions).to be_an(Array)
      transactions.each do |txn|
        expect(txn[:id]).to be_present
        expect(txn[:date]).to be_a(Date)
        expect(txn[:amount]).to be_a(Float)
        expect(txn[:currency]).to eq("EUR")
        expect(txn[:counterparty]).to be_present
        expect(txn[:type]).to be_in(%w[credit debit])
      end
    end

    it "returns transactions within date range" do
      transactions = client.transactions(from_date: from_date, to_date: to_date)

      transactions.each do |txn|
        expect(txn[:date]).to be >= from_date
        expect(txn[:date]).to be <= to_date
      end
    end

    it "respects limit parameter" do
      transactions = client.transactions(from_date: from_date, to_date: to_date, limit: 2)

      expect(transactions.length).to be <= 2
    end

    it "returns deterministic results for same date range" do
      first_call = client.transactions(from_date: from_date, to_date: to_date)
      second_call = client.transactions(from_date: from_date, to_date: to_date)

      expect(first_call.map { |t| t[:id] }).to eq(second_call.map { |t| t[:id] })
    end

    it "generates unique transaction IDs" do
      transactions = client.transactions(from_date: from_date - 30, to_date: to_date)
      ids = transactions.map { |t| t[:id] }

      expect(ids.uniq.length).to eq(ids.length)
    end

    it "includes both income and expense transactions" do
      # Use longer period to ensure variety
      transactions = client.transactions(from_date: from_date - 60, to_date: to_date, limit: 100)

      types = transactions.map { |t| t[:type] }.uniq
      expect(types).to include("credit")
      expect(types).to include("debit")
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/plugins/example_plugin/mock_bank_api_client_spec.rb`

### Task 4: Write specs for ExamplePlugin sync method

**File:** `spec/plugins/example_plugin_spec.rb`

```ruby
require "rails_helper"

RSpec.describe ExamplePlugin do
  describe "class methods" do
    it "returns plugin name" do
      expect(described_class.name).to eq("example")
    end

    it "returns version" do
      expect(described_class.version).to match(/\d+\.\d+\.\d+/)
    end

    it "returns description" do
      expect(described_class.description).to be_present
    end

    it "defines credential_fields" do
      fields = described_class.credential_fields
      expect(fields).to be_an(Array)

      api_key_field = fields.find { |f| f[:name] == "api_key" }
      expect(api_key_field).to be_present
      expect(api_key_field[:type]).to eq("password")
      expect(api_key_field[:required]).to be true
    end

    it "defines setting_fields" do
      fields = described_class.setting_fields
      expect(fields).to be_an(Array)

      date_field = fields.find { |f| f[:name] == "sync_from_date" }
      expect(date_field).to be_present
      expect(date_field[:type]).to eq("date")
    end
  end

  describe "#sync" do
    let(:plugin) { described_class.new }

    before do
      # Clean up any existing data
      MoneyTransaction.delete_all
      SyncHistory.delete_all
      Current.reset
    end

    context "without configuration" do
      it "fails with invalid credentials error" do
        result = plugin.sync

        expect(result[:success]).to be false
        expect(result[:error]).to include("Invalid API credentials")
      end

      it "creates a failed sync history" do
        plugin.sync

        history = SyncHistory.last
        expect(history.status).to eq("failed")
        expect(history.error_message).to include("credentials")
      end
    end

    context "with valid configuration" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123", account_id: "ACC001" }.to_json,
               settings: { sync_from_date: 7.days.ago.to_date.to_s, import_limit: "50" }.to_json)
      end

      it "returns success result" do
        result = plugin.sync

        expect(result[:success]).to be true
        expect(result[:records_processed]).to be >= 0
        expect(result[:records_created]).to be >= 0
      end

      it "creates MoneyTransaction records" do
        expect {
          plugin.sync
        }.to change(MoneyTransaction, :count)
      end

      it "creates transactions with correct source" do
        plugin.sync

        MoneyTransaction.all.each do |txn|
          expect(txn.source).to eq("example")
        end
      end

      it "creates transactions with external_id" do
        plugin.sync

        MoneyTransaction.all.each do |txn|
          expect(txn.external_id).to be_present
          expect(txn.external_id).to start_with("TXN_")
        end
      end

      it "stores raw transaction data" do
        plugin.sync

        txn = MoneyTransaction.first
        expect(txn.raw_data).to be_present
        raw = JSON.parse(txn.raw_data)
        expect(raw["id"]).to eq(txn.external_id)
      end

      it "creates completed sync history" do
        plugin.sync

        history = SyncHistory.last
        expect(history.status).to eq("completed")
        expect(history.records_processed).to be >= 0
        expect(history.records_created).to be >= 0
      end

      it "returns account info in result" do
        result = plugin.sync

        expect(result[:account_info]).to be_present
        expect(result[:account_info][:account_id]).to be_present
      end

      it "returns date range in result" do
        result = plugin.sync

        expect(result[:date_range]).to be_present
        expect(result[:date_range][:from]).to be_present
        expect(result[:date_range][:to]).to be_present
      end
    end

    context "deduplication" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json,
               settings: { sync_from_date: 7.days.ago.to_date.to_s }.to_json)
      end

      it "does not create duplicates on re-sync" do
        # First sync
        plugin.sync
        first_count = MoneyTransaction.count

        # Second sync with same data
        plugin.sync
        second_count = MoneyTransaction.count

        expect(second_count).to eq(first_count)
      end

      it "reports records_updated when data changes" do
        # This test verifies the dedup logic exists
        # In practice, mock data is deterministic so updates won't occur
        plugin.sync

        history = SyncHistory.last
        expect(history.records_updated).to be >= 0
      end
    end

    context "with custom settings" do
      it "respects import_limit setting" do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json,
               settings: { sync_from_date: 60.days.ago.to_date.to_s, import_limit: "5" }.to_json)

        plugin.sync

        # Should have at most 5 transactions
        expect(MoneyTransaction.count).to be <= 5
      end

      it "uses default 30 days when sync_from_date not set" do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json)

        result = plugin.sync

        from_date = result[:date_range][:from]
        expect(from_date).to eq(30.days.ago.to_date)
      end

      it "handles invalid date gracefully" do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json,
               settings: { sync_from_date: "invalid-date" }.to_json)

        result = plugin.sync

        # Should fall back to 30 days ago
        expect(result[:success]).to be true
        expect(result[:date_range][:from]).to eq(30.days.ago.to_date)
      end
    end

    context "transaction types" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json,
               settings: { sync_from_date: 60.days.ago.to_date.to_s, import_limit: "100" }.to_json)
      end

      it "creates both income and expense transactions" do
        plugin.sync

        income_count = MoneyTransaction.income.count
        expense_count = MoneyTransaction.expenses.count

        expect(income_count).to be > 0
        expect(expense_count).to be > 0
      end

      it "sets correct transaction_type based on API type" do
        plugin.sync

        # Verify by checking raw_data
        MoneyTransaction.all.each do |txn|
          raw = JSON.parse(txn.raw_data)
          if raw["type"] == "credit"
            expect(txn.transaction_type).to eq("income")
          else
            expect(txn.transaction_type).to eq("expense")
          end
        end
      end
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/plugins/example_plugin_spec.rb`

### Task 5: Write integration spec with SyncExecutionService

**File:** `spec/integration/example_plugin_sync_spec.rb`

```ruby
require "rails_helper"

RSpec.describe "ExamplePlugin integration", type: :integration do
  describe "full sync workflow via SyncExecutionService" do
    let(:service) { SyncExecutionService.new }

    before do
      MoneyTransaction.delete_all
      SyncHistory.delete_all
      DataAuditLog.delete_all
      Current.reset
    end

    context "with disabled plugin" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: false,
               credentials: { api_key: "valid_key_123" }.to_json)
      end

      it "returns not_enabled error" do
        result = service.execute(plugin_name: "example")

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:not_enabled)
      end
    end

    context "with enabled but unconfigured plugin" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: nil)
      end

      it "returns not_configured error" do
        result = service.execute(plugin_name: "example")

        expect(result[:success]).to be false
        expect(result[:error_type]).to eq(:not_configured)
      end
    end

    context "with fully configured plugin" do
      before do
        create(:plugin_configuration,
               plugin_name: "example",
               enabled: true,
               credentials: { api_key: "valid_api_key_123" }.to_json,
               settings: { sync_from_date: 14.days.ago.to_date.to_s }.to_json)
      end

      it "executes sync successfully" do
        result = service.execute(plugin_name: "example")

        expect(result[:success]).to be true
        expect(result[:plugin_name]).to eq("example")
        expect(result[:sync_history_id]).to be_present
      end

      it "creates MoneyTransaction records" do
        expect {
          service.execute(plugin_name: "example")
        }.to change(MoneyTransaction, :count)
      end

      it "creates SyncHistory record" do
        expect {
          service.execute(plugin_name: "example")
        }.to change(SyncHistory, :count).by(1)
      end

      it "records sync stats in history" do
        result = service.execute(plugin_name: "example")

        history = SyncHistory.find(result[:sync_history_id])
        expect(history.records_processed).to be > 0
        expect(history.records_created).to be > 0
        expect(history.completed_at).to be_present
      end

      it "creates audit logs for created transactions" do
        service.execute(plugin_name: "example")

        audit_logs = DataAuditLog.for_source("example")
        expect(audit_logs.count).to be > 0
        expect(audit_logs.first.action).to eq("create")
      end

      it "links audit logs to sync history" do
        result = service.execute(plugin_name: "example")

        audit_logs = DataAuditLog.for_sync(result[:sync_history_id])
        expect(audit_logs.count).to be > 0
      end
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/integration/example_plugin_sync_spec.rb`

### Task 6: Ensure directory structure and requires are correct

Create the directory for the mock client.

**Bash command:**
```bash
mkdir -p app/plugins/example_plugin
```

**Verification:**
- Directory exists

### Task 7: Update BasePlugin to use sync_with_audit in SyncExecutionService

Check if SyncExecutionService should call `sync_with_audit` instead of `sync`. Looking at the current implementation, it calls `sync` directly. For audit trail to work properly when called via the service, we should update the service.

**File:** `app/services/sync_execution_service.rb` (modify existing)

Update the `run_sync` method:

```ruby
# Run the actual sync operation
# @param plugin_class [Class] the plugin class to instantiate and sync
# @return [Hash] result hash with sync details
def run_sync(plugin_class)
  plugin = plugin_class.new

  # Use sync_with_audit to ensure all data changes are tracked
  # This sets Current.audit_source and Current.audit_sync_history_id
  sync_result = plugin.sync_with_audit

  {
    success: sync_result[:success],
    plugin_name: plugin_class.name,
    sync_history_id: sync_result[:sync_history_id],
    data: sync_result
  }
end
```

**Note:** This change means the plugin's `sync` method no longer needs to call `create_sync_history` itself - the `sync_with_audit` wrapper handles that. Update ExamplePlugin accordingly in Task 2.

**File:** `app/plugins/example_plugin.rb` (update sync method)

Remove the `history = create_sync_history` and `complete_sync`/`fail_sync` calls since `sync_with_audit` handles this:

```ruby
# Main sync method - fetches transactions from the bank and creates MoneyTransaction records
# Called by sync_with_audit which handles SyncHistory lifecycle
#
# @return [Hash] result with :success, :records_processed, :records_created, :records_updated, or :error
def sync
  # Validate credentials before proceeding
  client = build_api_client
  unless client.valid_credentials?
    return { success: false, error: "Invalid API credentials - key must be at least 8 characters" }
  end

  # Fetch transactions from the bank API
  from_date = sync_from_date
  to_date = Date.current
  limit = import_limit

  transactions = client.transactions(
    from_date: from_date,
    to_date: to_date,
    limit: limit
  )

  # Process each transaction
  stats = process_transactions(transactions)

  {
    success: true,
    records_processed: stats[:records_processed],
    records_created: stats[:records_created],
    records_updated: stats[:records_updated],
    date_range: { from: from_date, to: to_date },
    account_info: client.account_info
  }
end
```

Remove the `fail_and_return` method since it's no longer needed.

**Verification:**
- No syntax errors in both files

## Acceptance Criteria

- [ ] `ExamplePlugin::MockBankApiClient` generates realistic mock bank transactions
- [ ] Mock transactions are deterministic (same date range = same transactions)
- [ ] `ExamplePlugin#sync` fetches transactions and creates `MoneyTransaction` records
- [ ] Transactions are deduplicated via `external_id` + `source` uniqueness
- [ ] Settings are respected: `sync_from_date`, `import_limit`, `default_currency`
- [ ] Both income and expense transactions are created
- [ ] Raw transaction data is stored in `raw_data` column
- [ ] Sync result includes `records_processed`, `records_created`, `records_updated`
- [ ] Sync result includes `date_range` and `account_info`
- [ ] Integration with `SyncExecutionService` works correctly
- [ ] Audit logs are created for all transactions (via Auditable concern)
- [ ] All specs pass

## Rollback Plan

If issues are found:
1. Revert `app/plugins/example_plugin.rb` to stub version
2. Remove `app/plugins/example_plugin/mock_bank_api_client.rb`
3. Remove `app/plugins/example_plugin/` directory
4. Revert `app/services/sync_execution_service.rb` changes
5. Remove spec files

## Notes

- Mock API client uses date-based seeding for deterministic results - same date range always returns same transactions
- This enables reliable testing without mocking
- 70% of generated transactions are income, 30% are expenses (realistic for freelancer)
- Transaction IDs follow format `TXN_YYYYMMDD_NNN` for easy debugging
- Plugin version bumped to 2.0.0 to indicate breaking change from stub
- `sync_with_audit` is now the recommended entry point; direct `sync` calls work but miss audit context
