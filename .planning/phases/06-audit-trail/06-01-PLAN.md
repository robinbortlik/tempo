---
phase: 06-audit-trail
plan: 01
title: Audit trail implementation
subsystem: plugins
tags: [ruby, model, concern, audit, tracking]

# Dependency graph
requires:
  - phase: 05-sync-engine
    provides: [SyncExecutionService, SyncHistoryRecorder, plugin sync workflow]
  - phase: 02-plugin-interface
    provides: [BasePlugin class, sync method contract]
  - phase: 01-foundation
    provides: [MoneyTransaction model, SyncHistory model]
provides:
  - DataAuditLog model for tracking all data changes from plugins
  - Auditable concern for models requiring audit trail
  - Audit query methods per record and per plugin
  - Integration with plugin sync workflow
affects: [07-plugin-management-ui, 08-example-plugin]

# Tech tracking
tech-stack:
  added: []
  patterns:
    - "Audit log table for change tracking (custom implementation, no gems)"
    - "Rails concern for auditable behavior"
    - "Current attributes pattern for source attribution"
    - "JSON diff storage for change details"
---

# Plan: Audit Trail Implementation

**Goal:** Track all data changes from plugins with source attribution, enabling audit trail queries per record and per plugin

## Context

### From Phase 1 (Foundation)
- `MoneyTransaction` model exists for tracking financial transactions from external sources
- Model has `source` column identifying where data came from (e.g., "fio_bank")

### From Phase 2 (Plugin Interface)
- `BasePlugin` provides sync lifecycle helpers
- Plugins identify themselves via `name` class method

### From Phase 5 (Sync Engine)
- `SyncExecutionService` orchestrates plugin sync execution
- `SyncHistory` tracks when syncs run and their outcomes

### Design Decision: Custom vs. paper_trail Gem

**Decision:** Implement custom audit trail

**Rationale:**
1. **Simplicity:** paper_trail adds significant complexity for what we need
2. **Plugin-specific needs:** We need source attribution (which plugin made the change)
3. **Sync correlation:** We need to link changes to specific sync operations
4. **No versioning needed:** We only need audit log, not full version history with rollback
5. **Performance:** Custom solution can be tailored to our query patterns
6. **Minimal dependencies:** Aligns with project constraints (no external frameworks)

### This Phase Adds

1. `DataAuditLog` model to store audit entries
2. `Auditable` concern to include in models requiring tracking
3. `Current.audit_source` attribute for source attribution
4. Integration with BasePlugin to set audit context during sync

## Tasks

### Task 1: Create DataAuditLog migration and model

Create the audit log table and model that stores all change records.

**File:** `db/migrate/TIMESTAMP_create_data_audit_logs.rb`

```ruby
class CreateDataAuditLogs < ActiveRecord::Migration[8.1]
  def change
    create_table :data_audit_logs do |t|
      # What was changed
      t.string :auditable_type, null: false   # e.g., "MoneyTransaction"
      t.integer :auditable_id, null: false    # ID of the changed record

      # What happened
      t.string :action, null: false           # "create", "update", "destroy"
      t.json :changes_made                     # Hash of attribute changes (old -> new)

      # Who/what made the change
      t.string :source                         # Plugin name or "user"
      t.integer :sync_history_id               # Link to specific sync operation (optional)

      t.timestamps
    end

    add_index :data_audit_logs, [:auditable_type, :auditable_id]
    add_index :data_audit_logs, :source
    add_index :data_audit_logs, :sync_history_id
    add_index :data_audit_logs, :action
    add_index :data_audit_logs, :created_at
  end
end
```

**File:** `app/models/data_audit_log.rb`

```ruby
# Stores audit trail entries for data changes made by plugins
#
# Each entry records:
# - What record was changed (auditable_type + auditable_id)
# - What action occurred (create, update, destroy)
# - What changed (changes_made as JSON)
# - Who/what made the change (source, sync_history_id)
#
class DataAuditLog < ApplicationRecord
  # Associations
  belongs_to :auditable, polymorphic: true, optional: true
  belongs_to :sync_history, optional: true

  # Enums
  enum :action, { create_action: "create", update_action: "update", destroy_action: "destroy" }

  # Validations
  validates :auditable_type, presence: true
  validates :auditable_id, presence: true
  validates :action, presence: true

  # Scopes - By type
  scope :for_type, ->(type) { where(auditable_type: type) }
  scope :for_record, ->(record) { where(auditable_type: record.class.name, auditable_id: record.id) }
  scope :for_record_id, ->(type, id) { where(auditable_type: type, auditable_id: id) }

  # Scopes - By source
  scope :for_source, ->(source) { where(source: source) }
  scope :from_plugins, -> { where.not(source: ["user", nil]) }
  scope :from_user, -> { where(source: "user") }

  # Scopes - By action
  scope :creates, -> { create_action }
  scope :updates, -> { update_action }
  scope :destroys, -> { destroy_action }

  # Scopes - Time-based
  scope :recent, -> { order(created_at: :desc).limit(50) }
  scope :today, -> { where(created_at: Time.current.beginning_of_day..Time.current.end_of_day) }
  scope :for_sync, ->(sync_history_id) { where(sync_history_id: sync_history_id) }

  # Returns human-readable description of the change
  # @return [String] description like "Created MoneyTransaction #123"
  def description
    case action
    when "create"
      "Created #{auditable_type} ##{auditable_id}"
    when "update"
      changed_attrs = changes_made&.keys&.join(", ") || "attributes"
      "Updated #{auditable_type} ##{auditable_id} (#{changed_attrs})"
    when "destroy"
      "Destroyed #{auditable_type} ##{auditable_id}"
    end
  end

  # Returns summary hash for UI display
  # @return [Hash]
  def summary
    {
      id: id,
      auditable_type: auditable_type,
      auditable_id: auditable_id,
      action: action,
      source: source,
      sync_history_id: sync_history_id,
      changes_made: changes_made,
      description: description,
      created_at: created_at
    }
  end

  class << self
    # Returns statistics for a specific source (plugin)
    # @param source [String] the plugin name
    # @return [Hash] statistics
    def stats_for_source(source)
      scope = for_source(source)

      {
        source: source,
        total_changes: scope.count,
        creates: scope.creates.count,
        updates: scope.updates.count,
        destroys: scope.destroys.count,
        affected_records: scope.distinct.count(:auditable_id),
        affected_types: scope.distinct.pluck(:auditable_type),
        changes_today: scope.today.count,
        last_change: scope.order(created_at: :desc).first&.summary
      }
    end

    # Returns audit history for a specific record
    # @param record [ActiveRecord::Base] the record to get history for
    # @return [Array<Hash>] array of audit entry summaries
    def history_for(record)
      for_record(record).order(created_at: :desc).map(&:summary)
    end

    # Returns recent changes grouped by sync operation
    # @param limit [Integer] number of sync operations to include
    # @return [Hash] sync_history_id => [audit entries]
    def recent_by_sync(limit: 10)
      result = {}

      # Get distinct sync IDs from recent changes
      sync_ids = where.not(sync_history_id: nil)
                   .order(created_at: :desc)
                   .limit(limit * 10)
                   .distinct
                   .pluck(:sync_history_id)
                   .first(limit)

      sync_ids.each do |sync_id|
        result[sync_id] = for_sync(sync_id).order(created_at: :asc).map(&:summary)
      end

      result
    end
  end
end
```

**Verification:**
- Run migration: `bin/rails db:migrate`
- No syntax errors: `ruby -c app/models/data_audit_log.rb`
- Check schema includes data_audit_logs table

### Task 2: Create Auditable concern

Create a concern that can be included in models to enable automatic audit logging.

**File:** `app/models/concerns/auditable.rb`

```ruby
# Concern for models that should have their changes tracked in the audit log
#
# Usage:
#   class MoneyTransaction < ApplicationRecord
#     include Auditable
#   end
#
# All create, update, and destroy operations will be logged to DataAuditLog
# with source attribution from Current.audit_source
#
module Auditable
  extend ActiveSupport::Concern

  included do
    after_create :log_create
    after_update :log_update
    after_destroy :log_destroy
  end

  # Returns the audit history for this record
  # @return [Array<Hash>] array of audit entry summaries
  def audit_history
    DataAuditLog.history_for(self)
  end

  # Returns the most recent audit entry for this record
  # @return [DataAuditLog, nil]
  def last_audit_entry
    DataAuditLog.for_record(self).order(created_at: :desc).first
  end

  # Returns true if this record was created by a plugin
  # @return [Boolean]
  def created_by_plugin?
    first_audit = DataAuditLog.for_record(self).creates.order(created_at: :asc).first
    first_audit.present? && first_audit.source.present? && first_audit.source != "user"
  end

  # Returns the source that created this record
  # @return [String, nil]
  def created_by
    DataAuditLog.for_record(self).creates.order(created_at: :asc).first&.source
  end

  private

  def log_create
    log_audit_entry("create", nil)
  end

  def log_update
    return if saved_changes.blank?

    # Filter out timestamps and id from changes
    relevant_changes = saved_changes.except("id", "created_at", "updated_at")
    return if relevant_changes.blank?

    # Transform saved_changes format ([old, new]) to a cleaner format
    changes_hash = relevant_changes.transform_values do |change|
      { from: change[0], to: change[1] }
    end

    log_audit_entry("update", changes_hash)
  end

  def log_destroy
    # Store key attributes for reference after destruction
    final_state = attributes.except("id", "created_at", "updated_at")
    log_audit_entry("destroy", { final_state: final_state })
  end

  def log_audit_entry(action, changes)
    DataAuditLog.create!(
      auditable_type: self.class.name,
      auditable_id: id,
      action: action,
      changes_made: changes,
      source: Current.audit_source,
      sync_history_id: Current.audit_sync_history_id
    )
  rescue StandardError => e
    # Don't let audit logging failures break the main operation
    Rails.logger.error("Failed to create audit log: #{e.message}")
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/models/concerns/auditable.rb`
- File contains all callbacks and methods

### Task 3: Add audit context to Current class

Extend Rails Current class to hold audit context during plugin sync operations.

**File:** `app/models/current.rb`

```ruby
# Application-wide current attributes using Rails CurrentAttributes
#
# Provides thread-safe storage for:
# - audit_source: The source of data changes (plugin name or "user")
# - audit_sync_history_id: The SyncHistory ID for correlating changes
#
class Current < ActiveSupport::CurrentAttributes
  # Audit trail context
  attribute :audit_source
  attribute :audit_sync_history_id

  # Set audit context for plugin operations
  # @param source [String] plugin name or identifier
  # @param sync_history_id [Integer, nil] optional sync history ID
  def self.with_audit_context(source:, sync_history_id: nil)
    previous_source = audit_source
    previous_sync_history_id = audit_sync_history_id

    self.audit_source = source
    self.audit_sync_history_id = sync_history_id

    yield
  ensure
    self.audit_source = previous_source
    self.audit_sync_history_id = previous_sync_history_id
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/models/current.rb`
- File defines audit attributes and context method

### Task 4: Integrate audit context into BasePlugin

Update BasePlugin to automatically set audit context when running sync operations.

**File:** `app/plugins/base_plugin.rb` (modify existing)

Add the following method to BasePlugin class:

```ruby
# Executes the sync method within an audit context
# This ensures all data changes are attributed to this plugin
# @return [Hash] result from sync method
def sync_with_audit
  sync_history = create_sync_history
  sync_history.update!(status: :running)

  Current.with_audit_context(source: self.class.name, sync_history_id: sync_history.id) do
    begin
      result = sync

      if result[:success]
        complete_sync(sync_history, result.slice(:records_processed, :records_created, :records_updated))
      else
        fail_sync(sync_history, result[:error] || "Sync returned failure")
      end

      result.merge(sync_history_id: sync_history.id)
    rescue StandardError => e
      fail_sync(sync_history, e.message)
      raise
    end
  end
end
```

**Verification:**
- No syntax errors: `ruby -c app/plugins/base_plugin.rb`
- sync_with_audit method is present

### Task 5: Apply Auditable concern to MoneyTransaction

Update MoneyTransaction model to include the Auditable concern.

**File:** `app/models/money_transaction.rb` (modify existing)

```ruby
class MoneyTransaction < ApplicationRecord
  include Auditable

  # ... rest of existing code unchanged ...
end
```

**Verification:**
- No syntax errors: `ruby -c app/models/money_transaction.rb`
- Model includes Auditable

### Task 6: Write comprehensive specs for DataAuditLog

**File:** `spec/models/data_audit_log_spec.rb`

```ruby
require "rails_helper"

RSpec.describe DataAuditLog, type: :model do
  describe "validations" do
    it { is_expected.to validate_presence_of(:auditable_type) }
    it { is_expected.to validate_presence_of(:auditable_id) }
    it { is_expected.to validate_presence_of(:action) }
  end

  describe "associations" do
    it { is_expected.to belong_to(:sync_history).optional }
  end

  describe "enums" do
    it "defines action enum" do
      expect(described_class.actions).to include(
        "create_action" => "create",
        "update_action" => "update",
        "destroy_action" => "destroy"
      )
    end
  end

  describe "scopes" do
    let!(:create_log) { create(:data_audit_log, action: :create_action, source: "plugin1") }
    let!(:update_log) { create(:data_audit_log, action: :update_action, source: "plugin2") }
    let!(:destroy_log) { create(:data_audit_log, action: :destroy_action, source: "user") }

    describe ".for_source" do
      it "returns logs for specific source" do
        expect(described_class.for_source("plugin1")).to contain_exactly(create_log)
      end
    end

    describe ".from_plugins" do
      it "excludes user and nil sources" do
        expect(described_class.from_plugins).to contain_exactly(create_log, update_log)
      end
    end

    describe ".from_user" do
      it "returns user changes only" do
        expect(described_class.from_user).to contain_exactly(destroy_log)
      end
    end

    describe ".creates" do
      it "returns create actions only" do
        expect(described_class.creates).to contain_exactly(create_log)
      end
    end

    describe ".updates" do
      it "returns update actions only" do
        expect(described_class.updates).to contain_exactly(update_log)
      end
    end

    describe ".destroys" do
      it "returns destroy actions only" do
        expect(described_class.destroys).to contain_exactly(destroy_log)
      end
    end
  end

  describe "#description" do
    it "describes create action" do
      log = build(:data_audit_log, action: :create_action, auditable_type: "MoneyTransaction", auditable_id: 123)
      expect(log.description).to eq("Created MoneyTransaction #123")
    end

    it "describes update action with changed attributes" do
      log = build(:data_audit_log,
                  action: :update_action,
                  auditable_type: "MoneyTransaction",
                  auditable_id: 123,
                  changes_made: { "amount" => { from: 100, to: 200 }, "description" => { from: "old", to: "new" } })
      expect(log.description).to include("Updated MoneyTransaction #123")
      expect(log.description).to include("amount")
      expect(log.description).to include("description")
    end

    it "describes destroy action" do
      log = build(:data_audit_log, action: :destroy_action, auditable_type: "MoneyTransaction", auditable_id: 123)
      expect(log.description).to eq("Destroyed MoneyTransaction #123")
    end
  end

  describe "#summary" do
    let(:log) do
      create(:data_audit_log,
             action: :create_action,
             auditable_type: "MoneyTransaction",
             auditable_id: 123,
             source: "example",
             changes_made: { test: "data" })
    end

    it "returns hash with all expected keys" do
      summary = log.summary

      expect(summary[:id]).to eq(log.id)
      expect(summary[:auditable_type]).to eq("MoneyTransaction")
      expect(summary[:auditable_id]).to eq(123)
      expect(summary[:action]).to eq("create")
      expect(summary[:source]).to eq("example")
      expect(summary[:changes_made]).to eq({ "test" => "data" })
      expect(summary[:description]).to include("Created")
      expect(summary[:created_at]).to be_present
    end
  end

  describe ".stats_for_source" do
    before do
      3.times { create(:data_audit_log, source: "plugin1", action: :create_action, auditable_id: _1 + 1) }
      2.times { create(:data_audit_log, source: "plugin1", action: :update_action, auditable_id: 1) }
      create(:data_audit_log, source: "plugin1", action: :destroy_action, auditable_id: 3)
      create(:data_audit_log, source: "plugin2", action: :create_action)
    end

    let(:stats) { described_class.stats_for_source("plugin1") }

    it "returns correct counts" do
      expect(stats[:total_changes]).to eq(6)
      expect(stats[:creates]).to eq(3)
      expect(stats[:updates]).to eq(2)
      expect(stats[:destroys]).to eq(1)
    end

    it "counts affected records" do
      expect(stats[:affected_records]).to eq(3)
    end

    it "returns affected types" do
      expect(stats[:affected_types]).to include("MoneyTransaction")
    end

    it "returns last change" do
      expect(stats[:last_change]).to be_a(Hash)
      expect(stats[:last_change][:source]).to eq("plugin1")
    end
  end

  describe ".history_for" do
    let(:transaction) { create(:money_transaction) }

    before do
      Current.audit_source = "test_plugin"
      create(:data_audit_log, auditable: transaction, action: :create_action, created_at: 2.hours.ago)
      create(:data_audit_log, auditable: transaction, action: :update_action, created_at: 1.hour.ago)
      Current.audit_source = nil
    end

    it "returns audit history for record" do
      history = described_class.history_for(transaction)

      expect(history.count).to eq(2)
      expect(history.first[:action]).to eq("update") # Most recent first
      expect(history.last[:action]).to eq("create")
    end
  end

  describe ".recent_by_sync" do
    let(:sync1) { create(:sync_history, plugin_name: "plugin1") }
    let(:sync2) { create(:sync_history, plugin_name: "plugin2") }

    before do
      2.times { create(:data_audit_log, sync_history: sync1) }
      3.times { create(:data_audit_log, sync_history: sync2) }
      create(:data_audit_log, sync_history: nil) # No sync association
    end

    it "groups changes by sync operation" do
      result = described_class.recent_by_sync(limit: 10)

      expect(result.keys).to contain_exactly(sync1.id, sync2.id)
      expect(result[sync1.id].count).to eq(2)
      expect(result[sync2.id].count).to eq(3)
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/models/data_audit_log_spec.rb`
- All examples pass

### Task 7: Write specs for Auditable concern

**File:** `spec/models/concerns/auditable_spec.rb`

```ruby
require "rails_helper"

RSpec.describe Auditable, type: :model do
  # Use MoneyTransaction as test subject since it includes Auditable
  let(:transaction_attrs) do
    {
      source: "test_plugin",
      amount: 100.00,
      currency: "EUR",
      transacted_on: Date.current,
      transaction_type: :income
    }
  end

  before do
    # Ensure audit context is clean
    Current.audit_source = nil
    Current.audit_sync_history_id = nil
  end

  describe "after_create callback" do
    it "creates audit log entry for new record" do
      expect {
        MoneyTransaction.create!(transaction_attrs)
      }.to change(DataAuditLog, :count).by(1)
    end

    it "records create action" do
      transaction = MoneyTransaction.create!(transaction_attrs)

      log = DataAuditLog.last
      expect(log.auditable_type).to eq("MoneyTransaction")
      expect(log.auditable_id).to eq(transaction.id)
      expect(log.action).to eq("create")
    end

    it "records audit source from Current" do
      Current.audit_source = "fio_bank"

      MoneyTransaction.create!(transaction_attrs)

      log = DataAuditLog.last
      expect(log.source).to eq("fio_bank")
    end

    it "records sync_history_id from Current" do
      sync_history = create(:sync_history)
      Current.audit_sync_history_id = sync_history.id

      MoneyTransaction.create!(transaction_attrs)

      log = DataAuditLog.last
      expect(log.sync_history_id).to eq(sync_history.id)
    end
  end

  describe "after_update callback" do
    let!(:transaction) { MoneyTransaction.create!(transaction_attrs) }

    before do
      DataAuditLog.delete_all # Clear create log
    end

    it "creates audit log entry for updates" do
      expect {
        transaction.update!(amount: 200.00)
      }.to change(DataAuditLog, :count).by(1)
    end

    it "records update action" do
      transaction.update!(amount: 200.00)

      log = DataAuditLog.last
      expect(log.action).to eq("update")
    end

    it "records attribute changes" do
      transaction.update!(amount: 200.00, description: "Updated description")

      log = DataAuditLog.last
      expect(log.changes_made["amount"]).to eq({ "from" => 100.0, "to" => 200.0 })
      expect(log.changes_made["description"]).to be_present
    end

    it "excludes timestamp changes" do
      transaction.update!(amount: 200.00)

      log = DataAuditLog.last
      expect(log.changes_made.keys).not_to include("updated_at")
      expect(log.changes_made.keys).not_to include("created_at")
    end

    it "does not log when only timestamps change" do
      # Touch without attribute changes should not create audit entry
      # This is handled by the touch mechanism
      expect {
        transaction.touch
      }.not_to change { DataAuditLog.updates.count }
    end

    it "does not log when no relevant changes" do
      expect {
        transaction.save! # No changes
      }.not_to change(DataAuditLog, :count)
    end
  end

  describe "after_destroy callback" do
    let!(:transaction) { MoneyTransaction.create!(transaction_attrs) }

    before do
      DataAuditLog.delete_all # Clear create log
    end

    it "creates audit log entry for destroy" do
      expect {
        transaction.destroy!
      }.to change(DataAuditLog, :count).by(1)
    end

    it "records destroy action" do
      transaction.destroy!

      log = DataAuditLog.last
      expect(log.action).to eq("destroy")
    end

    it "records final state in changes" do
      transaction.destroy!

      log = DataAuditLog.last
      expect(log.changes_made["final_state"]).to include("amount" => 100.0)
      expect(log.changes_made["final_state"]).to include("source" => "test_plugin")
    end
  end

  describe "#audit_history" do
    let!(:transaction) { MoneyTransaction.create!(transaction_attrs) }

    before do
      transaction.update!(amount: 200.00)
      transaction.update!(description: "New description")
    end

    it "returns all audit entries for the record" do
      history = transaction.audit_history

      expect(history.count).to eq(3) # create + 2 updates
    end

    it "returns most recent first" do
      history = transaction.audit_history

      expect(history.first[:action]).to eq("update")
      expect(history.last[:action]).to eq("create")
    end
  end

  describe "#last_audit_entry" do
    let!(:transaction) { MoneyTransaction.create!(transaction_attrs) }

    it "returns most recent audit entry" do
      entry = transaction.last_audit_entry

      expect(entry).to be_a(DataAuditLog)
      expect(entry.action).to eq("create")
    end

    it "returns nil when no entries exist" do
      DataAuditLog.delete_all
      expect(transaction.last_audit_entry).to be_nil
    end
  end

  describe "#created_by_plugin?" do
    context "when created by a plugin" do
      before { Current.audit_source = "fio_bank" }

      it "returns true" do
        transaction = MoneyTransaction.create!(transaction_attrs)
        expect(transaction.created_by_plugin?).to be true
      end
    end

    context "when created by user" do
      before { Current.audit_source = "user" }

      it "returns false" do
        transaction = MoneyTransaction.create!(transaction_attrs)
        expect(transaction.created_by_plugin?).to be false
      end
    end

    context "when created without source" do
      before { Current.audit_source = nil }

      it "returns false" do
        transaction = MoneyTransaction.create!(transaction_attrs)
        expect(transaction.created_by_plugin?).to be false
      end
    end
  end

  describe "#created_by" do
    it "returns the source of the create entry" do
      Current.audit_source = "fio_bank"
      transaction = MoneyTransaction.create!(transaction_attrs)

      expect(transaction.created_by).to eq("fio_bank")
    end
  end

  describe "error handling" do
    it "does not break main operation if audit logging fails" do
      # Simulate audit log failure
      allow(DataAuditLog).to receive(:create!).and_raise(StandardError, "DB error")
      allow(Rails.logger).to receive(:error)

      # Main operation should still succeed
      expect {
        MoneyTransaction.create!(transaction_attrs)
      }.not_to raise_error
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/models/concerns/auditable_spec.rb`
- All examples pass

### Task 8: Write specs for Current audit context

**File:** `spec/models/current_spec.rb`

```ruby
require "rails_helper"

RSpec.describe Current do
  after do
    # Clean up thread-local state
    described_class.reset
  end

  describe "audit attributes" do
    it "stores audit_source" do
      described_class.audit_source = "test_plugin"
      expect(described_class.audit_source).to eq("test_plugin")
    end

    it "stores audit_sync_history_id" do
      described_class.audit_sync_history_id = 123
      expect(described_class.audit_sync_history_id).to eq(123)
    end
  end

  describe ".with_audit_context" do
    it "sets audit context within block" do
      described_class.with_audit_context(source: "plugin_name", sync_history_id: 456) do
        expect(described_class.audit_source).to eq("plugin_name")
        expect(described_class.audit_sync_history_id).to eq(456)
      end
    end

    it "restores previous context after block" do
      described_class.audit_source = "original"
      described_class.audit_sync_history_id = 100

      described_class.with_audit_context(source: "temporary", sync_history_id: 999) do
        # Inside block
      end

      expect(described_class.audit_source).to eq("original")
      expect(described_class.audit_sync_history_id).to eq(100)
    end

    it "restores context even if block raises" do
      described_class.audit_source = "original"

      expect {
        described_class.with_audit_context(source: "temporary") do
          raise "test error"
        end
      }.to raise_error("test error")

      expect(described_class.audit_source).to eq("original")
    end

    it "handles nested contexts" do
      described_class.with_audit_context(source: "outer", sync_history_id: 1) do
        expect(described_class.audit_source).to eq("outer")

        described_class.with_audit_context(source: "inner", sync_history_id: 2) do
          expect(described_class.audit_source).to eq("inner")
          expect(described_class.audit_sync_history_id).to eq(2)
        end

        expect(described_class.audit_source).to eq("outer")
        expect(described_class.audit_sync_history_id).to eq(1)
      end
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/models/current_spec.rb`
- All examples pass

### Task 9: Write specs for BasePlugin audit integration

**File:** `spec/plugins/base_plugin_audit_spec.rb`

```ruby
require "rails_helper"

RSpec.describe BasePlugin, "audit integration" do
  # Create a test plugin that creates MoneyTransaction during sync
  let(:test_plugin_class) do
    Class.new(BasePlugin) do
      def self.name
        "test_audit_plugin"
      end

      def self.version
        "1.0.0"
      end

      def self.description
        "Test plugin for audit integration"
      end

      def sync
        # Create a transaction during sync
        MoneyTransaction.create!(
          source: self.class.name,
          amount: 100.00,
          currency: "EUR",
          transacted_on: Date.current,
          transaction_type: :income
        )

        { success: true, records_processed: 1, records_created: 1, records_updated: 0 }
      end
    end
  end

  before do
    # Register the test plugin
    allow(PluginRegistry).to receive(:find!).with("test_audit_plugin").and_return(test_plugin_class)

    # Create configuration for the plugin
    create(:plugin_configuration,
           plugin_name: "test_audit_plugin",
           enabled: true,
           credentials: { api_key: "test" }.to_json)

    # Clean state
    Current.reset
  end

  after do
    Current.reset
  end

  describe "#sync_with_audit" do
    it "sets audit context during sync" do
      plugin = test_plugin_class.new

      captured_source = nil
      captured_sync_id = nil

      allow(MoneyTransaction).to receive(:create!).and_wrap_original do |method, *args|
        captured_source = Current.audit_source
        captured_sync_id = Current.audit_sync_history_id
        method.call(*args)
      end

      result = plugin.sync_with_audit

      expect(captured_source).to eq("test_audit_plugin")
      expect(captured_sync_id).to be_present
      expect(result[:success]).to be true
    end

    it "creates sync history before sync" do
      plugin = test_plugin_class.new

      expect {
        plugin.sync_with_audit
      }.to change(SyncHistory, :count).by(1)
    end

    it "returns sync history id in result" do
      plugin = test_plugin_class.new

      result = plugin.sync_with_audit

      expect(result[:sync_history_id]).to be_present
      expect(SyncHistory.find(result[:sync_history_id])).to be_present
    end

    it "marks sync as completed on success" do
      plugin = test_plugin_class.new

      result = plugin.sync_with_audit

      history = SyncHistory.find(result[:sync_history_id])
      expect(history.status).to eq("completed")
      expect(history.completed_at).to be_present
    end

    it "marks sync as failed on exception" do
      failing_plugin = Class.new(test_plugin_class) do
        def sync
          raise "Sync failed!"
        end
      end

      plugin = failing_plugin.new

      expect {
        plugin.sync_with_audit
      }.to raise_error("Sync failed!")

      history = SyncHistory.last
      expect(history.status).to eq("failed")
      expect(history.error_message).to eq("Sync failed!")
    end

    it "restores audit context after sync" do
      Current.audit_source = "original"

      plugin = test_plugin_class.new
      plugin.sync_with_audit

      expect(Current.audit_source).to eq("original")
    end

    it "creates audit log entries with correct source" do
      plugin = test_plugin_class.new

      expect {
        plugin.sync_with_audit
      }.to change(DataAuditLog, :count).by(1)

      log = DataAuditLog.last
      expect(log.source).to eq("test_audit_plugin")
      expect(log.action).to eq("create")
      expect(log.auditable_type).to eq("MoneyTransaction")
    end

    it "links audit entries to sync history" do
      plugin = test_plugin_class.new

      result = plugin.sync_with_audit

      log = DataAuditLog.last
      expect(log.sync_history_id).to eq(result[:sync_history_id])
    end
  end
end
```

**Verification:**
- Run: `bundle exec rspec spec/plugins/base_plugin_audit_spec.rb`
- All examples pass

### Task 10: Create factory for DataAuditLog

**File:** `spec/factories/data_audit_logs.rb`

```ruby
FactoryBot.define do
  factory :data_audit_log do
    auditable_type { "MoneyTransaction" }
    sequence(:auditable_id) { |n| n }
    action { :create_action }
    changes_made { nil }
    source { "test_plugin" }
    sync_history { nil }

    trait :create_action do
      action { :create_action }
      changes_made { nil }
    end

    trait :update_action do
      action { :update_action }
      changes_made { { "amount" => { "from" => 100, "to" => 200 } } }
    end

    trait :destroy_action do
      action { :destroy_action }
      changes_made { { "final_state" => { "amount" => 100, "source" => "test" } } }
    end

    trait :from_user do
      source { "user" }
    end

    trait :with_sync_history do
      association :sync_history
    end
  end
end
```

**Verification:**
- Factory can build valid records

## Acceptance Criteria

- [ ] `DataAuditLog` model exists with proper schema and validations
- [ ] `Auditable` concern automatically logs create, update, destroy operations
- [ ] `Current.audit_source` and `Current.audit_sync_history_id` store context
- [ ] `Current.with_audit_context` provides scoped context management
- [ ] `BasePlugin#sync_with_audit` sets audit context during sync execution
- [ ] `MoneyTransaction` includes `Auditable` concern
- [ ] Audit entries record source, sync_history_id, action, and changes
- [ ] `DataAuditLog.history_for(record)` returns audit history for any auditable record
- [ ] `DataAuditLog.stats_for_source(plugin_name)` returns audit statistics per plugin
- [ ] All specs pass: `bundle exec rspec spec/models/data_audit_log_spec.rb spec/models/concerns/auditable_spec.rb spec/models/current_spec.rb spec/plugins/base_plugin_audit_spec.rb`

## Rollback Plan

If issues are found:
1. Remove migration and model: `db/migrate/*_create_data_audit_logs.rb`, `app/models/data_audit_log.rb`
2. Remove concern: `app/models/concerns/auditable.rb`
3. Revert Current model changes: `app/models/current.rb`
4. Revert BasePlugin changes: `app/plugins/base_plugin.rb`
5. Revert MoneyTransaction changes: `app/models/money_transaction.rb`
6. Remove spec files

## Notes

- Custom audit implementation chosen over paper_trail for simplicity and plugin-specific features
- Audit logging is fire-and-forget (errors logged but don't break main operations)
- `sync_with_audit` is a new method that plugins can use; existing `sync` method unchanged
- SyncExecutionService may be updated in future to use `sync_with_audit` instead of `sync`
- The `Current` class uses Rails CurrentAttributes for thread-safe request-scoped storage
- Audit entries can be queried by record, by plugin, by sync operation, or globally
