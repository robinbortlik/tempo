---
phase: 02-plugin-interface
plan: 01
type: execute
depends_on: []
files_modified: [app/plugins/base_plugin.rb, spec/plugins/base_plugin_spec.rb]
---

<objective>
Create the plugin base class that defines the contract all plugins must follow.

Purpose: Establish the minimal interface (name, version, sync) that makes plugin development simple and consistent. This is the foundation for the entire plugin system.
Output: BasePlugin class with enforced contract, comprehensive specs, and clear error messages for violations.
</objective>

<execution_context>
./.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summary:
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Key files from Phase 1 (plugin infrastructure):
@app/models/plugin_configuration.rb
@app/models/sync_history.rb
@app/models/money_transaction.rb

# Existing service patterns to follow:
@app/services/invoice_builder.rb

# Standards:
@agent-os/standards/backend/services.md

**Tech stack available:** Rails 8.1, Ruby 3.3, RSpec
**Established patterns:**
- ActiveRecord attribute encryption for credentials
- Enum status tracking (pending, running, completed, failed)
- Service objects with result pattern ({success:, data:} or {success:, errors:})

**Constraining decisions:**
- Phase 1: PluginConfiguration stores credentials per plugin_name
- Phase 1: SyncHistory tracks sync operations with status enum

**Core value reminder:** "If developers can't add a new integration in one file with three methods, the architecture has failed."
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BasePlugin class with interface contract</name>
  <files>app/plugins/base_plugin.rb</files>
  <action>
Create `app/plugins/base_plugin.rb` with a BasePlugin class that defines:

1. Required class methods that subclasses MUST override:
   - `name` - returns the plugin's unique identifier (string)
   - `version` - returns semantic version string (e.g., "1.0.0")
   - `description` - returns human-readable description

2. Required instance method that subclasses MUST override:
   - `sync` - performs the actual sync operation, must return a result hash

3. Built-in helpers that BasePlugin provides:
   - `configuration` - returns PluginConfiguration record for this plugin
   - `credentials` - returns parsed credentials hash from configuration
   - `settings` - returns parsed settings hash from configuration
   - `create_sync_history` - creates SyncHistory with pending status
   - `complete_sync(sync_history, stats)` - marks sync as completed with stats
   - `fail_sync(sync_history, error)` - marks sync as failed with error message

4. Contract enforcement:
   - Raise `NotImplementedError` with helpful message if required methods not overridden
   - Include the plugin class name in error messages

Structure:
```ruby
class BasePlugin
  class << self
    def name
      raise NotImplementedError, "#{self} must implement .name"
    end
    # ... version, description
  end

  def sync
    raise NotImplementedError, "#{self.class} must implement #sync"
  end

  # Helper methods
  def configuration
    @configuration ||= PluginConfiguration.find_by(plugin_name: self.class.name)
  end
  # ...
end
```

Keep it simple - no metaprogramming, no DSLs, just plain Ruby methods.
  </action>
  <verify>ruby -c app/plugins/base_plugin.rb (syntax check passes)</verify>
  <done>BasePlugin class exists with name, version, description class methods and sync instance method, all raising NotImplementedError with helpful messages</done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive specs for BasePlugin</name>
  <files>spec/plugins/base_plugin_spec.rb</files>
  <action>
Create RSpec tests that verify:

1. Interface contract enforcement:
   - Calling BasePlugin.name raises NotImplementedError
   - Calling BasePlugin.version raises NotImplementedError
   - Calling BasePlugin.description raises NotImplementedError
   - Calling BasePlugin.new.sync raises NotImplementedError
   - Error messages include the class name for debugging

2. Subclass contract:
   - Create a test double class that implements all required methods
   - Verify it can be instantiated and call sync
   - Verify partial implementation (missing some methods) still raises for missing ones

3. Helper method behavior:
   - `configuration` returns nil when no PluginConfiguration exists
   - `configuration` returns the correct record when it exists
   - `credentials` returns parsed hash from configuration
   - `settings` returns parsed hash from configuration
   - `create_sync_history` creates a pending SyncHistory record
   - `complete_sync` updates status and sets completed_at/stats
   - `fail_sync` updates status and sets error_message

Use FactoryBot for PluginConfiguration fixtures if factory exists, otherwise create inline.

Structure:
```ruby
RSpec.describe BasePlugin do
  describe "interface contract" do
    # ...
  end

  describe "with proper subclass" do
    let(:plugin_class) do
      Class.new(BasePlugin) do
        def self.name = "test_plugin"
        def self.version = "1.0.0"
        def self.description = "Test plugin"
        def sync = { success: true, records_processed: 0 }
      end
    end
    # ...
  end

  describe "helper methods" do
    # ...
  end
end
```
  </action>
  <verify>bundle exec rspec spec/plugins/base_plugin_spec.rb --format documentation</verify>
  <done>All specs pass, covering interface contract enforcement, subclass behavior, and helper methods</done>
</task>

<task type="auto">
  <name>Task 3: Create example plugin stub for documentation</name>
  <files>app/plugins/example_plugin.rb</files>
  <action>
Create a minimal example plugin that demonstrates the contract:

```ruby
# Example plugin demonstrating the BasePlugin interface.
# Copy this as a starting point for new plugins.
#
# Required:
#   - Override self.name, self.version, self.description (class methods)
#   - Override #sync (instance method) returning { success: true/false, ... }
#
# Available helpers:
#   - configuration: PluginConfiguration record for this plugin
#   - credentials: parsed credentials hash
#   - settings: parsed settings hash
#   - create_sync_history: creates SyncHistory with pending status
#   - complete_sync(history, stats): marks sync completed
#   - fail_sync(history, error): marks sync failed

class ExamplePlugin < BasePlugin
  def self.name
    "example"
  end

  def self.version
    "1.0.0"
  end

  def self.description
    "Example plugin for documentation purposes"
  end

  def sync
    history = create_sync_history

    begin
      # Your sync logic here:
      # 1. Fetch data from external API using credentials
      # 2. Process and store data
      # 3. Return stats

      records_processed = 0
      complete_sync(history, records_processed: records_processed)

      { success: true, records_processed: records_processed }
    rescue StandardError => e
      fail_sync(history, e.message)
      { success: false, error: e.message }
    end
  end
end
```

This serves as living documentation - developers copy this file to create new plugins.
  </action>
  <verify>ruby -c app/plugins/example_plugin.rb && bundle exec rspec spec/plugins/base_plugin_spec.rb</verify>
  <done>ExamplePlugin class exists, inherits from BasePlugin, implements all required methods, and includes documentation comments</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `ruby -c app/plugins/base_plugin.rb` passes (valid Ruby syntax)
- [ ] `ruby -c app/plugins/example_plugin.rb` passes (valid Ruby syntax)
- [ ] `bundle exec rspec spec/plugins/base_plugin_spec.rb` passes all tests
- [ ] BasePlugin raises NotImplementedError for unimplemented methods
- [ ] ExamplePlugin can be instantiated and sync called
- [ ] Helper methods work with PluginConfiguration and SyncHistory models
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Plugin contract is clear: name, version, description, sync
- Developers can create a new plugin by copying ExamplePlugin
- Phase 2 complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-plugin-interface/02-01-SUMMARY.md`:

Use template from ./summary.md with frontmatter including:
- phase: 02-plugin-interface
- plan: 01
- subsystem: plugins
- tags: [ruby, plugin-system, interface]
- requires: [01-01]
- provides: [BasePlugin class, plugin contract definition]
- affects: [03-plugin-registry, 05-sync-engine, 08-example-plugin]
</output>
